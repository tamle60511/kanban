This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
cmd/
  server/
    main.go
config/
  config.go
database/
  database.go
internal/
  app/
    app.go
  dto/
    auth.go
    department.go
    report.go
    role.go
    user.go
  handlers/
    admin_handler.go
    auth_handler.go
    department_handler.go
    operation_handler.go
    report_handler.go
    role_handler.go
    user_handler.go
  middleware/
    auth.go
    department_filter.go
    role_check.go
  models/
    access_log.go
    department.go
    operation.go
    role.go
    user.go
  repository/
    access_log_repository.go
    department_repository.go
    operation_repository.go
    report_repository.go
    role_repository.go
    user_repository.go
  service/
    auth_service.go
    department_service.go
    operation_service.go
    report_service.go
    role_service.go
    user_service.go
  utils/
    excel_exporter.go
    file.go
    password.go
    response.go
    validator.go
config.yaml
go.mod

================================================================
Files
================================================================

================
File: cmd/server/main.go
================
package main

import (
	"erp-excel/config"
	"erp-excel/database"
	"erp-excel/internal/app"
)

func main() {
	// Load configuration
	cfg := config.MustConfig()

	// Connect to database
	db := database.MustDatabase(cfg)

	// Create application
	application := app.New(cfg, db)

	// Setup routes
	application.SetupRoutes()

	// Start application
	application.Start()
}

================
File: config/config.go
================
package config

import (
	"fmt"
	"log"
	"os"
	"time"

	"github.com/spf13/viper"
)

type Config struct {
	Server      ServerConfig   `mapstructure:"server"`
	Database    DatabaseConfig `mapstructure:"database"`
	ERPDatabase DatabaseConfig `mapstructure:"erp_database"`
	JWT         JWTConfig      `mapstructure:"jwt"`
	Excel       ExcelConfig    `mapstructure:"excel"`
	Logger      LoggerConfig   `mapstructure:"logger"`
}

type ServerConfig struct {
	Name string `mapstructure:"name"`
	Port string `mapstructure:"port"`
	Env  string `mapstructure:"env"`
}

type DatabaseConfig struct {
	Host     string        `mapstructure:"host"`
	Port     int           `mapstructure:"port"`
	User     string        `mapstructure:"user"`
	Password string        `mapstructure:"password"`
	DBName   string        `mapstructure:"name"`
	Timeout  time.Duration `mapstructure:"timeout"`
}

type JWTConfig struct {
	Secret     string `mapstructure:"secret"`
	ExpiryHour int    `mapstructure:"expiry_hour"`
}

type ExcelConfig struct {
	DownloadPath    string `mapstructure:"download_path"`
	MaxSearchMonths int    `mapstructure:"max_search_months"`
}

type LoggerConfig struct {
	Level string `mapstructure:"level"`
	Path  string `mapstructure:"path"`
}

func LoadConfig() (*Config, error) {
	configPath := os.Getenv("CONFIG_PATH")
	if configPath == "" {
		configPath = "."
	}

	viper.SetConfigName("config")
	viper.SetConfigType("yaml")
	viper.AddConfigPath(configPath)

	// Set default values
	viper.SetDefault("server.port", "8080")
	viper.SetDefault("database.timeout", 10)
	viper.SetDefault("jwt.expiry_hour", 24)
	viper.SetDefault("excel.max_search_months", 6)
	viper.SetDefault("excel.download_path", "public/downloads")

	if err := viper.ReadInConfig(); err != nil {
		return nil, fmt.Errorf("error reading config: %w", err)
	}

	config := &Config{}
	if err := viper.Unmarshal(config); err != nil {
		return nil, fmt.Errorf("error unmarshaling config: %w", err)
	}

	return config, nil
}

func MustConfig() *Config {
	cfg, err := LoadConfig()
	if err != nil {
		log.Fatalf("Fatal error loading config: %s", err)
	}
	return cfg
}

// GetDSN returns SQL Server connection string
func (c *Config) GetDSN() string {
	// Format: sqlserver://username:password@host:port?database=dbname
	return fmt.Sprintf(
		"sqlserver://%s:%s@%s:%d?database=%s&encrypt=disable&trustServerCertificate=true",
		c.Database.User,
		c.Database.Password,
		c.Database.Host,
		c.Database.Port,
		c.Database.DBName,
	)
}

func (c *Config) GetERPDatabaseDSN() string {
	return fmt.Sprintf("sqlserver://%s:%s@%s:%d?database=%s&encrypt=disable&trustServerCertificate=true&connection timeout=%d",
		c.ERPDatabase.User,
		c.ERPDatabase.Password,
		c.ERPDatabase.Host,
		c.ERPDatabase.Port,
		c.ERPDatabase.DBName,
		c.ERPDatabase.Timeout,
	)
}

// GetJWTExpiry returns JWT expiry duration
func (c *Config) GetJWTExpiry() time.Duration {
	return time.Duration(c.JWT.ExpiryHour) * time.Hour
}

================
File: database/database.go
================
package database

import (
	"context"
	"database/sql"
	"erp-excel/config"

	"fmt"
	"log"
	"time"

	_ "github.com/denisenkom/go-mssqldb"
)

// Database interface
type Database interface {
	DB() *sql.DB
	ERPDatabase() *sql.DB // Add missing method declaration
	Close() error
	Ping() error
}

type database struct {
	db    *sql.DB
	erpDB *sql.DB
}

// NewDatabase creates a new database connection
func NewDatabase(cfg *config.Config) (Database, error) {
	db, err := sql.Open("sqlserver", cfg.GetDSN())
	if err != nil {
		return nil, fmt.Errorf("error connecting to database: %w", err)
	}

	erpDB, err := sql.Open("sqlserver", cfg.GetERPDatabaseDSN())
	// log.Printf("Database connection: %v", erpDB)
	if err != nil {
		db.Close() // Close the first DB connection if ERP DB fails
		return nil, fmt.Errorf("error opening ERP database: %w", err)
	}

	// Kiểm tra kết nối ERP database
	if err := erpDB.Ping(); err != nil {
		db.Close() // Close both connections if ping fails
		erpDB.Close()
		return nil, fmt.Errorf("error pinging ERP database: %w", err)
	}

	// Set connection pool settings
	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(5)
	db.SetConnMaxLifetime(time.Minute * 5)

	// Test connection
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := db.PingContext(ctx); err != nil {
		db.Close() // Close connections if ping fails
		erpDB.Close()
		return nil, fmt.Errorf("error pinging database: %w", err)
	}

	return &database{
		db:    db,
		erpDB: erpDB,
	}, nil
}

// MustDatabase panics if database connection fails
func MustDatabase(cfg *config.Config) Database {
	db, err := NewDatabase(cfg)
	if err != nil {
		log.Fatalf("Fatal database connection error: %s", err)
	}
	return db
}

// DB returns the database connection
func (d *database) DB() *sql.DB {
	return d.db
}

// ERPDatabase returns the ERP database connection
func (d *database) ERPDatabase() *sql.DB {
	return d.erpDB
}

// Close closes both database connections
func (d *database) Close() error {
	// Close both databases and track potential errors
	var errs []error

	if err := d.db.Close(); err != nil {
		errs = append(errs, fmt.Errorf("error closing main database: %w", err))
	}

	if err := d.erpDB.Close(); err != nil {
		errs = append(errs, fmt.Errorf("error closing ERP database: %w", err))
	}

	if len(errs) > 0 {
		return fmt.Errorf("errors closing databases: %v", errs)
	}

	return nil
}

// Ping checks if the database connection is alive
func (d *database) Ping() error {
	// Ping both databases
	if err := d.db.Ping(); err != nil {
		return fmt.Errorf("error pinging main database: %w", err)
	}

	if err := d.erpDB.Ping(); err != nil {
		return fmt.Errorf("error pinging ERP database: %w", err)
	}

	return nil
}

// ExecuteScript runs a SQL script to initialize database
func (d *database) ExecuteScript(script string) error {
	_, err := d.db.Exec(script)
	if err != nil {
		return fmt.Errorf("error executing script: %w", err)
	}
	return nil
}

================
File: internal/app/app.go
================
package app

import (
	"erp-excel/config"
	"erp-excel/database"
	"erp-excel/internal/handlers"
	"erp-excel/internal/middleware"
	"erp-excel/internal/repository"
	"erp-excel/internal/service"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/gofiber/fiber/v2/middleware/logger"
	"github.com/gofiber/fiber/v2/middleware/recover"
)

// App represents the application
type App struct {
	config         *config.Config
	fiber          *fiber.App
	db             database.Database
	authService    service.AuthService
	handlers       []interface{} // List of all handlers
	userRepo       repository.UserRepository
	departmentRepo repository.DepartmentRepository
	roleRepo       repository.RoleRepository
	operationRepo  repository.OperationRepository
	reportRepo     repository.InventoryRepository
}

// New creates a new application instance
func New(cfg *config.Config, db database.Database) *App {
	app := &App{
		config: cfg,
		db:     db,
	}

	// Initialize Fiber
	app.fiber = fiber.New(fiber.Config{
		AppName:      cfg.Server.Name,
		ErrorHandler: errorHandler,
	})

	// Setup middleware
	app.fiber.Use(recover.New())
	app.fiber.Use(logger.New())
	app.fiber.Use(cors.New(cors.Config{
		AllowOrigins:     "http://localhost:3000",
		AllowMethods:     "GET,POST,PUT,DELETE",
		AllowHeaders:     "Origin,Content-Type,Accept,Authorization",
		AllowCredentials: true,
	}))

	// Setup repositories
	app.userRepo = repository.NewUserRepository(app.db.DB())
	app.departmentRepo = repository.NewDepartmentRepository(app.db.DB())
	app.roleRepo = repository.NewRoleRepository(app.db.DB())
	app.operationRepo = repository.NewOperationRepository(app.db.DB())
	app.reportRepo = repository.NewInventoryRepository(app.db.ERPDatabase())

	// Setup services
	app.authService = service.NewAuthService(app.userRepo, app.config)
	userService := service.NewUserService(app.userRepo, app.departmentRepo, app.roleRepo, app.authService)
	departmentService := service.NewDepartmentService(app.departmentRepo)
	roleService := service.NewRoleService(app.roleRepo)
	operationService := service.NewOperationService(app.operationRepo, app.userRepo, app.roleRepo)
	reportService := service.NewReportService(
		app.db.ERPDatabase(),
		app.config,
		app.userRepo,
		app.operationRepo,
		app.reportRepo,
	)

	// Setup handlers
	authHandler := handlers.NewAuthHandler(app.authService)
	userHandler := handlers.NewUserHandler(userService)
	departmentHandler := handlers.NewDepartmentHandler(departmentService)
	roleHandler := handlers.NewRoleHandler(roleService)
	reportHandler := handlers.NewReportHandler(reportService, app.reportRepo)
	operationHandler := handlers.NewOperationHandler(operationService)
	adminHandler := handlers.NewAdminHandler(userService, departmentService, roleService, operationService)

	// Store handlers
	app.handlers = []interface{}{
		authHandler,
		userHandler,
		departmentHandler,
		roleHandler,
		reportHandler,
		adminHandler,
		operationHandler,
	}

	return app
}

// SetupRoutes configures the application routes
func (a *App) SetupRoutes() {
	// Health check endpoint
	a.fiber.Get("/health", func(c *fiber.Ctx) error {
		return c.JSON(fiber.Map{
			"status": "ok",
			"name":   a.config.Server.Name,
			"env":    a.config.Server.Env,
		})
	})

	// Static files for downloads
	a.fiber.Static("/downloads", "./public/downloads")

	// API routes
	api := a.fiber.Group("/api")

	// Public routes
	auth := api.Group("/auth")
	handlers.NewAuthHandler(a.authService).SetupRoutes(auth)

	// Protected routes
	protected := api.Group("/", middleware.JWTMiddleware(a.authService))

	// Setup all handler routes
	for _, h := range a.handlers {
		if handler, ok := h.(interface{ SetupRoutes(router fiber.Router) }); ok {
			handler.SetupRoutes(protected)
		}
	}

	// 404 handler
	a.fiber.Use(func(c *fiber.Ctx) error {
		return c.Status(404).JSON(fiber.Map{
			"success": false,
			"message": "Not Found",
			"error":   "The requested resource does not exist",
		})
	})
}

// Start starts the application
func (a *App) Start() {
	// Setup signal handling for graceful shutdown
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	// Start server in a goroutine
	go func() {
		addr := fmt.Sprintf(":%s", a.config.Server.Port)
		if err := a.fiber.Listen(addr); err != nil {
			log.Fatalf("Error starting server: %v", err)
		}
	}()

	log.Printf("Server started on port %s", a.config.Server.Port)

	// Wait for interrupt signal
	<-sigChan
	log.Println("Shutting down server...")

	// Close database connection
	if err := a.db.Close(); err != nil {
		log.Printf("Error closing database connection: %v", err)
	}

	// Shutdown server
	if err := a.fiber.Shutdown(); err != nil {
		log.Fatalf("Error shutting down server: %v", err)
	}

	log.Println("Server gracefully stopped")
}

// errorHandler handles API errors
func errorHandler(c *fiber.Ctx, err error) error {
	code := fiber.StatusInternalServerError
	message := "Internal Server Error"

	if e, ok := err.(*fiber.Error); ok {
		code = e.Code
		message = e.Message
	}

	return c.Status(code).JSON(fiber.Map{
		"success": false,
		"message": message,
		"error":   err.Error(),
	})
}

================
File: internal/dto/auth.go
================
package dto

// LoginRequest represents login credentials
type LoginRequest struct {
	Username string `json:"username" validate:"required"`
	Password string `json:"password" validate:"required"`
}

// LoginResponse represents login response with tokens
type LoginResponse struct {
	User  *UserResponse `json:"user"`
	Token string        `json:"token"`
}

// TokenClaims represents JWT claims
type TokenClaims struct {
	UserID       int    `json:"user_id"`
	Username     string `json:"username"`
	DepartmentID int    `json:"department_id"`
	Exp          int64  `json:"exp"`
}

================
File: internal/dto/department.go
================
package dto

// DepartmentResponse represents department data for API responses
type DepartmentResponse struct {
	ID          int    `json:"id"`
	Name        string `json:"name"`
	Code        string `json:"code"`
	Description string `json:"description,omitempty"`
	IsActive    bool   `json:"is_active"`
	UserCount   int    `json:"user_count,omitempty"`
}

// CreateDepartmentRequest represents request to create a new department
type CreateDepartmentRequest struct {
	Name        string `json:"name" validate:"required"`
	Code        string `json:"code" validate:"required,min=2,max=20"`
	Description string `json:"description" validate:"omitempty"`
	IsActive    *bool  `json:"is_active" validate:"omitempty"`
}

// UpdateDepartmentRequest represents request to update a department
type UpdateDepartmentRequest struct {
	Name        string `json:"name" validate:"omitempty"`
	Description string `json:"description" validate:"omitempty"`
	IsActive    *bool  `json:"is_active" validate:"omitempty"`
}

================
File: internal/dto/report.go
================
package dto

import "time"

// DateRangeRequest defines the request body for report generation with flexible date input.
type DateRangeRequest struct {
	FromDate time.Time `json:"fromDate"` // Optional: If Period is provided, these might be ignored
	ToDate   time.Time `json:"toDate"`   // Optional: If Period is provided, these might be ignored
	Period   string    `json:"period"`   // New: e.g., "7days", "30days", "3months", "currentmonth", "lastmonth"
}

// InventoryReportItem represents a single item in the inventory report.
type InventoryReportItem struct {
	NgayCT           string `json:"ngayCT"`
	MaDonBanHang     string `json:"maDonBanHang"`
	KhachHang        string `json:"khachHang"`
	MaPhieuKetSo     string `json:"maPhieuKetSo"`
	NguyenTe         string `json:"nguyenTe"`
	NoiTe            string `json:"noiTe"`
	MaDonHangChiTiet string `json:"maDonHangChiTiet"`
	HoaDon           string `json:"hoaDon"`
	GhiChu           string `json:"ghiChu"`
}

// ReportDataResponse is the structure for API response when viewing report data (JSON).
type ReportDataResponse struct {
	ReportName  string                `json:"reportName"`
	GeneratedAt time.Time             `json:"generatedAt"`
	Items       []InventoryReportItem `json:"items"`
}

// ReportFileResponse is the structure for API response when generating an Excel file.
type ReportFileResponse struct {
	ReportName  string    `json:"reportName"`
	FilePath    string    `json:"filePath"` // Internal path on server
	FileName    string    `json:"fileName"` // Name of the file for download
	URL         string    `json:"url"`      // Public URL to download the file
	GeneratedAt time.Time `json:"generatedAt"`
}

================
File: internal/dto/role.go
================
package dto

import "time"

// RoleResponse represents role data for API responses
type RoleResponse struct {
	ID           int       `json:"id"`
	Name         string    `json:"name"`
	Description  string    `json:"description,omitempty"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	OperationIDs []int     `json:"operation_ids,omitempty"`
	UserCount    int       `json:"user_count,omitempty"`
}

// CreateRoleRequest represents request to create a new role
type CreateRoleRequest struct {
	Name         string `json:"name" validate:"required"`
	Description  string `json:"description" validate:"omitempty"`
	OperationIDs []int  `json:"operation_ids" validate:"omitempty,dive,min=1"`
}

// UpdateRoleRequest represents request to update a role
type UpdateRoleRequest struct {
	Name         string `json:"name" validate:"omitempty"`
	Description  string `json:"description" validate:"omitempty"`
	OperationIDs []int  `json:"operation_ids" validate:"omitempty,dive,min=1"`
}

// OperationResponse represents operation data for API responses
type OperationResponse struct {
	ID          int    `json:"id"`
	Name        string `json:"name"`
	Code        string `json:"code"`
	Description string `json:"description,omitempty"`
}

================
File: internal/dto/user.go
================
package dto

import "time"

// UserResponse represents user data for API responses
type UserResponse struct {
	ID           int       `json:"id"`
	Username     string    `json:"username"`
	FullName     string    `json:"full_name"`
	Email        string    `json:"email"`
	Phone        string    `json:"phone,omitempty"`
	DepartmentID int       `json:"department_id"`
	Department   string    `json:"department,omitempty"`
	IsActive     bool      `json:"is_active"`
	CreatedAt    time.Time `json:"created_at"`
	Roles        []string  `json:"roles,omitempty"`
}

// CreateUserRequest represents request to create a new user
type CreateUserRequest struct {
	Username     string `json:"username" validate:"required,min=3,max=50"`
	Password     string `json:"password" validate:"required,min=6"`
	FullName     string `json:"full_name" validate:"required"`
	Email        string `json:"email" validate:"required,email"`
	Phone        string `json:"phone" validate:"omitempty"`
	DepartmentID int    `json:"department_id" validate:"required,min=1"`
	RoleIDs      []int  `json:"role_ids" validate:"required,min=1,dive,min=1"`
}

// UpdateUserRequest represents request to update a user
type UpdateUserRequest struct {
	FullName     string `json:"full_name" validate:"omitempty"`
	Email        string `json:"email" validate:"omitempty,email"`
	Phone        string `json:"phone" validate:"omitempty"`
	DepartmentID int    `json:"department_id" validate:"omitempty,min=1"`
	IsActive     *bool  `json:"is_active" validate:"omitempty"`
}

// UpdatePasswordRequest represents request to update user password
type UpdatePasswordRequest struct {
	CurrentPassword string `json:"current_password" validate:"required"`
	NewPassword     string `json:"new_password" validate:"required,min=6"`
	ConfirmPassword string `json:"confirm_password" validate:"required,eqfield=NewPassword"`
}

================
File: internal/handlers/admin_handler.go
================
package handlers

import (
	"erp-excel/internal/service"
	"erp-excel/internal/utils"

	"github.com/gofiber/fiber/v2"
)

// AdminHandler handles admin operations
type AdminHandler struct {
	userService       service.UserService
	departmentService service.DepartmentService
	roleService       service.RoleService
	operationService  service.OperationService
}

// NewAdminHandler creates a new admin handler
func NewAdminHandler(
	userService service.UserService,
	departmentService service.DepartmentService,
	roleService service.RoleService,
	operationService service.OperationService,
) *AdminHandler {
	return &AdminHandler{
		userService:       userService,
		departmentService: departmentService,
		roleService:       roleService,
		operationService:  operationService,
	}
}

// Dashboard returns admin dashboard statistics
func (h *AdminHandler) Dashboard(c *fiber.Ctx) error {
	userCount, err := h.userService.CountUsers(c.Context())
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error getting user count",
			err.Error(),
		))
	}

	deptCount, err := h.departmentService.CountDepartments(c.Context())
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error getting department count",
			err.Error(),
		))
	}

	roleCount, err := h.roleService.CountRoles(c.Context())
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error getting role count",
			err.Error(),
		))
	}

	// Get recent access logs
	logs, err := h.operationService.GetRecentLogs(c.Context(), 10)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error getting recent logs",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		fiber.Map{
			"user_count":       userCount,
			"department_count": deptCount,
			"role_count":       roleCount,
			"recent_logs":      logs,
		},
		"Dashboard data retrieved successfully",
	))
}

// GetSystemOperations gets all system operations
func (h *AdminHandler) GetSystemOperations(c *fiber.Ctx) error {
	operations, err := h.operationService.GetAllOperations(c.Context())
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error getting operations",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		operations,
		"Operations retrieved successfully",
	))
}

// SetupRoutes sets up the handler routes
func (h *AdminHandler) SetupRoutes(router fiber.Router) {
	admin := router.Group("/admin")

	admin.Get("/dashboard", h.Dashboard)
	admin.Get("/operations", h.GetSystemOperations)
}

================
File: internal/handlers/auth_handler.go
================
package handlers

import (
	"erp-excel/internal/dto"
	"erp-excel/internal/service"
	"erp-excel/internal/utils"

	"github.com/gofiber/fiber/v2"
)

// AuthHandler handles authentication requests
type AuthHandler struct {
	authService service.AuthService
}

// NewAuthHandler creates a new auth handler
func NewAuthHandler(authService service.AuthService) *AuthHandler {
	return &AuthHandler{
		authService: authService,
	}
}

// Login handles user login
func (h *AuthHandler) Login(c *fiber.Ctx) error {
	var request dto.LoginRequest
	if err := c.BodyParser(&request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid request",
			"Error parsing request body",
		))
	}

	// Validate request
	if err := utils.ValidateStruct(request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Validation error",
			err.Error(),
		))
	}

	// Attempt login
	response, err := h.authService.Login(c.Context(), request)
	if err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(utils.ErrorResponse(
			"Login failed",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		response,
		"Login successful",
	))
}

// GetProfile retrieves the current user's profile
func (h *AuthHandler) GetProfile(c *fiber.Ctx) error {
	userID, ok := c.Locals("user_id").(int)
	if !ok || userID == 0 {
		return c.Status(fiber.StatusUnauthorized).JSON(utils.ErrorResponse(
			"Authentication required",
			"User not authenticated",
		))
	}

	profile, err := h.authService.GetUserProfile(c.Context(), userID)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error retrieving profile",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		profile,
		"Profile retrieved successfully",
	))
}

// SetupRoutes sets up the handler routes
func (h *AuthHandler) SetupRoutes(router fiber.Router) {
	router.Post("/login", h.Login)

	// Protected routes
	protected := router.Group("/", func(c *fiber.Ctx) error {
		userID, ok := c.Locals("user_id").(int)
		if !ok || userID == 0 {
			return c.Status(fiber.StatusUnauthorized).JSON(utils.ErrorResponse(
				"Authentication required",
				"User not authenticated",
			))
		}
		return c.Next()
	})

	protected.Get("/profile", h.GetProfile)
}

================
File: internal/handlers/department_handler.go
================
package handlers

import (
	"erp-excel/internal/dto"
	"erp-excel/internal/service"
	"erp-excel/internal/utils"
	"strconv"

	"github.com/gofiber/fiber/v2"
)

// DepartmentHandler handles department operations
type DepartmentHandler struct {
	departmentService service.DepartmentService
}

// NewDepartmentHandler creates a new department handler
func NewDepartmentHandler(departmentService service.DepartmentService) *DepartmentHandler {
	return &DepartmentHandler{
		departmentService: departmentService,
	}
}

// GetAll retrieves all departments
func (h *DepartmentHandler) GetAll(c *fiber.Ctx) error {
	// Parse pagination parameters
	page, _ := strconv.Atoi(c.Query("page", "1"))
	limit, _ := strconv.Atoi(c.Query("limit", "10"))

	// Handle invalid pagination
	if page < 1 {
		page = 1
	}
	if limit < 1 || limit > 100 {
		limit = 10
	}

	// Calculate offset
	offset := (page - 1) * limit

	// Get departments
	departments, err := h.departmentService.GetAllDepartments(c.Context(), limit, offset)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error retrieving departments",
			err.Error(),
		))
	}

	// Get total count for pagination
	total, err := h.departmentService.CountDepartments(c.Context())
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error counting departments",
			err.Error(),
		))
	}

	// Calculate pagination info
	totalPages := (total + limit - 1) / limit
	hasNext := page < totalPages
	hasPrev := page > 1

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		fiber.Map{
			"departments": departments,
			"pagination": fiber.Map{
				"total":       total,
				"page":        page,
				"limit":       limit,
				"total_pages": totalPages,
				"has_next":    hasNext,
				"has_prev":    hasPrev,
			},
		},
		"Departments retrieved successfully",
	))
}

// GetByID retrieves a department by ID
func (h *DepartmentHandler) GetByID(c *fiber.Ctx) error {
	id, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid department ID",
			"Department ID must be a number",
		))
	}

	department, err := h.departmentService.GetDepartmentByID(c.Context(), id)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(utils.ErrorResponse(
			"Department not found",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		department,
		"Department retrieved successfully",
	))
}

// Create creates a new department
func (h *DepartmentHandler) Create(c *fiber.Ctx) error {
	var request dto.CreateDepartmentRequest
	if err := c.BodyParser(&request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid request",
			"Error parsing request body",
		))
	}

	// Validate request
	if err := utils.ValidateStruct(request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Validation error",
			err.Error(),
		))
	}

	// Create department
	department, err := h.departmentService.CreateDepartment(c.Context(), request)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error creating department",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusCreated).JSON(utils.SuccessResponse(
		department,
		"Department created successfully",
	))
}

// Update updates a department
func (h *DepartmentHandler) Update(c *fiber.Ctx) error {
	id, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid department ID",
			"Department ID must be a number",
		))
	}

	var request dto.UpdateDepartmentRequest
	if err := c.BodyParser(&request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid request",
			"Error parsing request body",
		))
	}

	// Validate request
	if err := utils.ValidateStruct(request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Validation error",
			err.Error(),
		))
	}

	// Update department
	department, err := h.departmentService.UpdateDepartment(c.Context(), id, request)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error updating department",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		department,
		"Department updated successfully",
	))
}

// Delete deactivates a department
func (h *DepartmentHandler) Delete(c *fiber.Ctx) error {
	id, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid department ID",
			"Department ID must be a number",
		))
	}

	if err := h.departmentService.DeleteDepartment(c.Context(), id); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error deleting department",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		nil,
		"Department deleted successfully",
	))
}

// SetupRoutes sets up the handler routes
func (h *DepartmentHandler) SetupRoutes(router fiber.Router) {
	departments := router.Group("/departments")

	departments.Get("/", h.GetAll)
	departments.Get("/:id", h.GetByID)
	departments.Post("/", h.Create)
	departments.Put("/:id", h.Update)
	departments.Delete("/:id", h.Delete)
}

================
File: internal/handlers/operation_handler.go
================
package handlers

import (
	"erp-excel/internal/service"
	"erp-excel/internal/utils"
	"strconv"

	"github.com/gofiber/fiber/v2"
)

// OperationHandler handles operation-related HTTP requests
type OperationHandler struct {
	operationService service.OperationService
}

// NewOperationHandler creates a new operation handler
func NewOperationHandler(operationService service.OperationService) *OperationHandler {
	return &OperationHandler{
		operationService: operationService,
	}
}

// GetAllOperations retrieves all operations
func (h *OperationHandler) GetAllOperations(c *fiber.Ctx) error {
	operations, err := h.operationService.GetAllOperations(c.Context())
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error retrieving operations",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		operations,
		"Operations retrieved successfully",
	))
}

// CheckUserAccess checks if a user has access to a specific operation
func (h *OperationHandler) CheckUserAccess(c *fiber.Ctx) error {
	// Parse user ID from request
	userID, err := strconv.Atoi(c.Params("userID"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid user ID",
			"User ID must be a number",
		))
	}

	// Get operation code from request
	operationCode := c.Params("operationCode")
	if operationCode == "" {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid operation code",
			"Operation code cannot be empty",
		))
	}

	// Check user access
	hasAccess, err := h.operationService.CheckUserAccess(c.Context(), userID, operationCode)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error checking user access",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		fiber.Map{
			"has_access": hasAccess,
		},
		"User access checked successfully",
	))
}

// LogAccess logs access to an operation
func (h *OperationHandler) LogAccess(c *fiber.Ctx) error {
	// Parse request body
	var requestBody struct {
		UserID        int         `json:"user_id"`
		OperationCode string      `json:"operation_code"`
		Params        interface{} `json:"params,omitempty"`
	}

	if err := c.BodyParser(&requestBody); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid request body",
			"Error parsing request body",
		))
	}

	// Validate input
	if requestBody.UserID <= 0 || requestBody.OperationCode == "" {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid input",
			"User ID and operation code are required",
		))
	}

	// Get client IP address
	ipAddress := c.IP()

	// Log access
	logID, err := h.operationService.LogAccess(
		c.Context(),
		requestBody.UserID,
		requestBody.OperationCode,
		requestBody.Params,
		ipAddress,
	)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error logging access",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusCreated).JSON(utils.SuccessResponse(
		fiber.Map{
			"log_id": logID,
		},
		"Access logged successfully",
	))
}

// UpdateLogStatus updates the status of an access log
func (h *OperationHandler) UpdateLogStatus(c *fiber.Ctx) error {
	// Parse log ID from URL parameter
	logID, err := strconv.Atoi(c.Params("logID"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid log ID",
			"Log ID must be a number",
		))
	}

	// Parse request body
	var requestBody struct {
		Status string `json:"status"`
	}

	if err := c.BodyParser(&requestBody); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid request body",
			"Error parsing request body",
		))
	}

	// Validate status
	if requestBody.Status == "" {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid status",
			"Status cannot be empty",
		))
	}

	// Update log status
	updated, err := h.operationService.UpdateLogStatus(c.Context(), logID, requestBody.Status)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error updating log status",
			err.Error(),
		))
	}

	if !updated {
		return c.Status(fiber.StatusNotFound).JSON(utils.ErrorResponse(
			"Log not found",
			"No log found with the given ID",
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		nil,
		"Log status updated successfully",
	))
}

// GetRecentLogs retrieves recent access logs
func (h *OperationHandler) GetRecentLogs(c *fiber.Ctx) error {
	// Parse limit from query parameter
	limit, _ := strconv.Atoi(c.Query("limit", "10"))

	// Get recent logs
	logs, err := h.operationService.GetRecentLogs(c.Context(), limit)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error retrieving recent logs",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		logs,
		"Recent logs retrieved successfully",
	))
}

// SetupRoutes sets up the routes for operation-related endpoints
func (h *OperationHandler) SetupRoutes(router fiber.Router) {
	operations := router.Group("/operations")

	// Get all operations
	operations.Get("/", h.GetAllOperations)

	// Check user access to an operation
	operations.Get("/access/:userID/:operationCode", h.CheckUserAccess)

	// Log access to an operation
	operations.Post("/log", h.LogAccess)

	// Update log status
	operations.Put("/log/:logID/status", h.UpdateLogStatus)

	// Get recent logs
	operations.Get("/logs/recent", h.GetRecentLogs)
}

================
File: internal/handlers/report_handler.go
================
package handlers

import (
	"fmt"
	"log"
	"path/filepath"
	"time"

	"erp-excel/internal/dto"
	"erp-excel/internal/repository"
	"erp-excel/internal/service"
	"erp-excel/internal/utils"

	"github.com/gofiber/fiber/v2"
)

// ReportHandler handles report generation requests.
type ReportHandler struct {
	reportService service.ReportService
	reportRepo    repository.InventoryRepository // Keep if needed elsewhere, though service wraps it.
}

// NewReportHandler creates a new report handler.
func NewReportHandler(
	reportService service.ReportService,
	reportRepo repository.InventoryRepository,
) *ReportHandler {
	return &ReportHandler{
		reportService: reportService,
		reportRepo:    reportRepo,
	}
}

// GetInventoryReportData handles requests to get inventory report data (JSON response).
func (h *ReportHandler) GetInventoryReportData(c *fiber.Ctx) error {
	// Get user from context
	userID, ok := c.Locals("user_id").(int)
	if !ok || userID == 0 {
		return c.Status(fiber.StatusUnauthorized).JSON(utils.ErrorResponse(
			"Authentication required",
			"User not authenticated",
		))
	}

	departmentID, ok := c.Locals("department_id").(int)
	if !ok {
		departmentID = 0 // Default to all departments if not specified
	}

	// Parse request body
	var request dto.DateRangeRequest
	if err := c.BodyParser(&request); err != nil {
		log.Printf("Error parsing request body for inventory data: %v", err)
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid request",
			"Error parsing request body: "+err.Error(),
		))
	}

	// Validate request (using the enhanced ValidateStruct)
	if err := utils.ValidateStruct(&request); err != nil {
		log.Printf("Validation error for inventory data: %v", err)
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Validation error",
			err.Error(),
		))
	}

	// Get report data from service
	items, err := h.reportService.GetInventoryReportData(c.Context(), userID, departmentID, &request)
	if err != nil {
		log.Printf("Error getting inventory report data: %v", err)
		// Provide more user-friendly messages for specific errors
		if err.Error() == "no data found to export for the specified date range" { // This exact message is from service
			return c.Status(fiber.StatusNotFound).JSON(utils.ErrorResponse(
				"No Data Found",
				"No data available for the selected period.",
			))
		}
		// Generic internal server error
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error retrieving report data",
			err.Error(),
		))
	}

	// Determine report title based on the request (period or specific dates)
	reportTitle := "Báo cáo tồn kho"
	if request.Period != "" {
		reportTitle = fmt.Sprintf("Báo cáo tồn kho: %s", formatPeriod(request.Period))
	} else if !request.FromDate.IsZero() && !request.ToDate.IsZero() {
		reportTitle = fmt.Sprintf("Báo cáo tồn kho từ %s đến %s",
			request.FromDate.Format("02/01/2006"),
			request.ToDate.Format("02/01/2006"),
		)
	}

	// Return response with data
	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		dto.ReportDataResponse{
			ReportName:  reportTitle,
			GeneratedAt: time.Now(),
			Items:       items,
		},
		"Report data retrieved successfully",
	))
}

// formatPeriod helper for display purposes
func formatPeriod(period string) string {
	switch period {
	case "7days":
		return "7 ngày gần nhất"
	case "30days":
		return "30 ngày gần nhất"
	case "3months":
		return "3 tháng gần nhất"
	case "currentmonth":
		return "Tháng hiện tại"
	case "lastmonth":
		return "Tháng trước"
	default:
		return period
	}
}

// ExportInventoryReport handles requests to export inventory report to Excel.
func (h *ReportHandler) ExportInventoryReport(c *fiber.Ctx) error {
	// Get user from context
	userID, ok := c.Locals("user_id").(int)
	if !ok || userID == 0 {
		return c.Status(fiber.StatusUnauthorized).JSON(utils.ErrorResponse(
			"Authentication required",
			"User not authenticated",
		))
	}

	departmentID, ok := c.Locals("department_id").(int)
	if !ok {
		departmentID = 0 // Default to all departments if not specified
	}

	// Parse request body
	var request dto.DateRangeRequest
	if err := c.BodyParser(&request); err != nil {
		log.Printf("Error parsing request body for inventory export: %v", err)
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid request",
			"Error parsing request body: "+err.Error(),
		))
	}

	// Validate request
	if err := utils.ValidateStruct(&request); err != nil {
		log.Printf("Validation error for inventory export: %v", err)
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Validation error",
			err.Error(),
		))
	}

	// Generate and export report file
	reportFileResponse, err := h.reportService.ExportInventoryReport(c.Context(), userID, departmentID, &request)
	if err != nil {
		log.Printf("Error exporting inventory report: %v", err)
		if err.Error() == "no data found to export for the specified date range" {
			return c.Status(fiber.StatusNotFound).JSON(utils.ErrorResponse(
				"No Data Found",
				"No data found for the specified date range to export.",
			))
		}
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error exporting report",
			err.Error(),
		))
	}

	// Return file information for download by frontend
	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		reportFileResponse,
		"Report file generated successfully",
	))
}

// DownloadInventoryReport downloads an inventory report file.
func (h *ReportHandler) DownloadInventoryReport(c *fiber.Ctx) error {
	// Get filename from request parameters
	fileName := c.Params("fileName")
	if fileName == "" {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid request",
			"Filename is required",
		))
	}

	// Ensure no path manipulation by using filepath.Base
	fileName = filepath.Base(fileName)
	filePath := filepath.Join("public", "downloads", fileName) // Correct path structure

	// Check if file exists
	if !utils.FileExists(filePath) {
		return c.Status(fiber.StatusNotFound).JSON(utils.ErrorResponse(
			"File not found",
			"The requested file does not exist",
		))
	}

	// Return file for download
	return c.Download(filePath, fileName)
}

// SetupRoutes sets up the handler routes.
func (h *ReportHandler) SetupRoutes(router fiber.Router) {
	reports := router.Group("/reports")

	// Inventory reports
	reports.Post("/inventory", h.GetInventoryReportData)          // Returns JSON data for display
	reports.Post("/inventory/export", h.ExportInventoryReport)    // Generates Excel file and returns file info
	reports.Get("/download/:fileName", h.DownloadInventoryReport) // Downloads the specific file
}

================
File: internal/handlers/role_handler.go
================
package handlers

import (
	"erp-excel/internal/dto"
	"erp-excel/internal/service"
	"erp-excel/internal/utils"
	"strconv"

	"github.com/gofiber/fiber/v2"
)

// RoleHandler handles role operations
type RoleHandler struct {
	roleService service.RoleService
}

// NewRoleHandler creates a new role handler
func NewRoleHandler(roleService service.RoleService) *RoleHandler {
	return &RoleHandler{
		roleService: roleService,
	}
}

// GetAll retrieves all roles
func (h *RoleHandler) GetAll(c *fiber.Ctx) error {
	// Parse pagination parameters
	page, _ := strconv.Atoi(c.Query("page", "1"))
	limit, _ := strconv.Atoi(c.Query("limit", "10"))

	// Handle invalid pagination
	if page < 1 {
		page = 1
	}
	if limit < 1 || limit > 100 {
		limit = 10
	}

	// Calculate offset
	offset := (page - 1) * limit

	// Get roles
	roles, err := h.roleService.GetAllRoles(c.Context(), limit, offset)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error retrieving roles",
			err.Error(),
		))
	}

	// Get total count for pagination
	total, err := h.roleService.CountRoles(c.Context())
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error counting roles",
			err.Error(),
		))
	}

	// Calculate pagination info
	totalPages := (total + limit - 1) / limit
	hasNext := page < totalPages
	hasPrev := page > 1

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		fiber.Map{
			"roles": roles,
			"pagination": fiber.Map{
				"total":       total,
				"page":        page,
				"limit":       limit,
				"total_pages": totalPages,
				"has_next":    hasNext,
				"has_prev":    hasPrev,
			},
		},
		"Roles retrieved successfully",
	))
}

// GetByID retrieves a role by ID
func (h *RoleHandler) GetByID(c *fiber.Ctx) error {
	id, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid role ID",
			"Role ID must be a number",
		))
	}

	role, err := h.roleService.GetRoleByID(c.Context(), id)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(utils.ErrorResponse(
			"Role not found",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		role,
		"Role retrieved successfully",
	))
}

// Create creates a new role
func (h *RoleHandler) Create(c *fiber.Ctx) error {
	var request dto.CreateRoleRequest
	if err := c.BodyParser(&request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid request",
			"Error parsing request body",
		))
	}

	// Validate request
	if err := utils.ValidateStruct(request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Validation error",
			err.Error(),
		))
	}

	// Create role
	role, err := h.roleService.CreateRole(c.Context(), request)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error creating role",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusCreated).JSON(utils.SuccessResponse(
		role,
		"Role created successfully",
	))
}

// Update updates a role
func (h *RoleHandler) Update(c *fiber.Ctx) error {
	id, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid role ID",
			"Role ID must be a number",
		))
	}

	var request dto.UpdateRoleRequest
	if err := c.BodyParser(&request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid request",
			"Error parsing request body",
		))
	}

	// Validate request
	if err := utils.ValidateStruct(request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Validation error",
			err.Error(),
		))
	}

	// Update role
	role, err := h.roleService.UpdateRole(c.Context(), id, request)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error updating role",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		role,
		"Role updated successfully",
	))
}

// Delete deletes a role
func (h *RoleHandler) Delete(c *fiber.Ctx) error {
	id, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid role ID",
			"Role ID must be a number",
		))
	}

	if err := h.roleService.DeleteRole(c.Context(), id); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error deleting role",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		nil,
		"Role deleted successfully",
	))
}

// SetupRoutes sets up the handler routes
func (h *RoleHandler) SetupRoutes(router fiber.Router) {
	roles := router.Group("/roles")

	roles.Get("/", h.GetAll)
	roles.Get("/:id", h.GetByID)
	roles.Post("/", h.Create)
	roles.Put("/:id", h.Update)
	roles.Delete("/:id", h.Delete)
}

================
File: internal/handlers/user_handler.go
================
package handlers

import (
	"erp-excel/internal/dto"
	"erp-excel/internal/service"
	"erp-excel/internal/utils"
	"strconv"

	"github.com/gofiber/fiber/v2"
)

// UserHandler handles user operations
type UserHandler struct {
	userService service.UserService
}

// NewUserHandler creates a new user handler
func NewUserHandler(userService service.UserService) *UserHandler {
	return &UserHandler{
		userService: userService,
	}
}

// GetAll retrieves all users
func (h *UserHandler) GetAll(c *fiber.Ctx) error {
	// Parse pagination parameters
	page, _ := strconv.Atoi(c.Query("page", "1"))
	limit, _ := strconv.Atoi(c.Query("limit", "10"))

	// Handle invalid pagination
	if page < 1 {
		page = 1
	}
	if limit < 1 || limit > 100 {
		limit = 10
	}

	// Calculate offset
	offset := (page - 1) * limit

	// Get users
	users, err := h.userService.GetAllUsers(c.Context(), limit, offset)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error retrieving users",
			err.Error(),
		))
	}

	// Get total count for pagination
	total, err := h.userService.CountUsers(c.Context())
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error counting users",
			err.Error(),
		))
	}

	// Calculate pagination info
	totalPages := (total + limit - 1) / limit
	hasNext := page < totalPages
	hasPrev := page > 1

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		fiber.Map{
			"users": users,
			"pagination": fiber.Map{
				"total":       total,
				"page":        page,
				"limit":       limit,
				"total_pages": totalPages,
				"has_next":    hasNext,
				"has_prev":    hasPrev,
			},
		},
		"Users retrieved successfully",
	))
}

// GetByID retrieves a user by ID
func (h *UserHandler) GetByID(c *fiber.Ctx) error {
	id, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid user ID",
			"User ID must be a number",
		))
	}

	user, err := h.userService.GetUserByID(c.Context(), id)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(utils.ErrorResponse(
			"User not found",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		user,
		"User retrieved successfully",
	))
}

// Create creates a new user
func (h *UserHandler) Create(c *fiber.Ctx) error {
	var request dto.CreateUserRequest
	if err := c.BodyParser(&request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid request",
			"Error parsing request body",
		))
	}

	// Validate request
	if err := utils.ValidateStruct(request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Validation error",
			err.Error(),
		))
	}

	// Create user
	user, err := h.userService.CreateUser(c.Context(), request)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error creating user",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusCreated).JSON(utils.SuccessResponse(
		user,
		"User created successfully",
	))
}

// Update updates a user
func (h *UserHandler) Update(c *fiber.Ctx) error {
	id, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid user ID",
			"User ID must be a number",
		))
	}

	var request dto.UpdateUserRequest
	if err := c.BodyParser(&request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid request",
			"Error parsing request body",
		))
	}

	// Validate request
	if err := utils.ValidateStruct(request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Validation error",
			err.Error(),
		))
	}

	// Update user
	user, err := h.userService.UpdateUser(c.Context(), id, request)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error updating user",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		user,
		"User updated successfully",
	))
}

// UpdatePassword updates a user's password
func (h *UserHandler) UpdatePassword(c *fiber.Ctx) error {
	// Get current user ID
	userID, ok := c.Locals("user_id").(int)
	if !ok || userID == 0 {
		return c.Status(fiber.StatusUnauthorized).JSON(utils.ErrorResponse(
			"Authentication required",
			"User not authenticated",
		))
	}

	var request dto.UpdatePasswordRequest
	if err := c.BodyParser(&request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid request",
			"Error parsing request body",
		))
	}

	// Validate request
	if err := utils.ValidateStruct(request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Validation error",
			err.Error(),
		))
	}

	// Update password
	if err := h.userService.UpdateUserPassword(c.Context(), userID, request); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error updating password",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		nil,
		"Password updated successfully",
	))
}

// Delete deactivates a user
func (h *UserHandler) Delete(c *fiber.Ctx) error {
	id, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid user ID",
			"User ID must be a number",
		))
	}

	if err := h.userService.DeleteUser(c.Context(), id); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error deleting user",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		nil,
		"User deleted successfully",
	))
}

// AssignRoles assigns roles to a user
func (h *UserHandler) AssignRoles(c *fiber.Ctx) error {
	id, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid user ID",
			"User ID must be a number",
		))
	}

	var request struct {
		RoleIDs []int `json:"role_ids" validate:"required,min=1,dive,min=1"`
	}

	if err := c.BodyParser(&request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Invalid request",
			"Error parsing request body",
		))
	}

	// Validate request
	if err := utils.ValidateStruct(request); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(utils.ErrorResponse(
			"Validation error",
			err.Error(),
		))
	}

	// Assign roles
	if err := h.userService.AssignRolesToUser(c.Context(), id, request.RoleIDs); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
			"Error assigning roles",
			err.Error(),
		))
	}

	return c.Status(fiber.StatusOK).JSON(utils.SuccessResponse(
		nil,
		"Roles assigned successfully",
	))
}

// SetupRoutes sets up the handler routes
func (h *UserHandler) SetupRoutes(router fiber.Router) {
	users := router.Group("/users")

	users.Get("/", h.GetAll)
	users.Get("/:id", h.GetByID)
	users.Post("/", h.Create)
	users.Put("/:id", h.Update)
	users.Delete("/:id", h.Delete)
	users.Post("/:id/roles", h.AssignRoles)
	users.Post("/password", h.UpdatePassword)
}

================
File: internal/middleware/auth.go
================
package middleware

import (
	"erp-excel/internal/service"
	"erp-excel/internal/utils"
	"strings"

	"github.com/gofiber/fiber/v2"
)

// JWTMiddleware validates JWT tokens
func JWTMiddleware(authService service.AuthService) fiber.Handler {
	return func(c *fiber.Ctx) error {
		// Get the JWT token from the request
		authHeader := c.Get("Authorization")

		// Check if auth header exists
		if authHeader == "" {
			return c.Status(fiber.StatusUnauthorized).JSON(utils.ErrorResponse(
				"Authorization required",
				"Missing Authorization header",
			))
		}

		// Check if auth header format is valid
		parts := strings.Split(authHeader, " ")
		if len(parts) != 2 || parts[0] != "Bearer" {
			return c.Status(fiber.StatusUnauthorized).JSON(utils.ErrorResponse(
				"Invalid authorization format",
				"Authorization header must be in format: Bearer {token}",
			))
		}

		// Validate token
		tokenString := parts[1]
		claims, err := authService.ValidateToken(tokenString)
		if err != nil {
			return c.Status(fiber.StatusUnauthorized).JSON(utils.ErrorResponse(
				"Invalid token",
				err.Error(),
			))
		}

		// Set user info in context
		c.Locals("user_id", claims.UserID)
		c.Locals("username", claims.Username)
		c.Locals("department_id", claims.DepartmentID)

		// Continue to next handler
		return c.Next()
	}
}

================
File: internal/middleware/department_filter.go
================
package middleware

import (
	"erp-excel/internal/utils"

	"github.com/gofiber/fiber/v2"
)

// DepartmentFilterMiddleware filters data based on user's department
func DepartmentFilterMiddleware(adminOnly bool) fiber.Handler {
	return func(c *fiber.Ctx) error {
		// Get department ID from context
		departmentID, ok := c.Locals("department_id").(int)
		if !ok {
			departmentID = 0
		}

		// Check if user is admin by looking at department ID = 0
		// This is simplified - in a real app, you'd check role permissions
		isAdmin := departmentID == 0

		// If route is admin-only and user is not admin, reject
		if adminOnly && !isAdmin {
			return c.Status(fiber.StatusForbidden).JSON(utils.ErrorResponse(
				"Permission denied",
				"This operation requires administrative privileges",
			))
		}

		// Store department info for filtering
		c.Locals("is_admin", isAdmin)

		// Always include department ID for data filtering
		c.Locals("filter_department_id", departmentID)

		return c.Next()
	}
}

================
File: internal/middleware/role_check.go
================
package middleware

import (
	"erp-excel/internal/service"
	"erp-excel/internal/utils"

	"github.com/gofiber/fiber/v2"
)

// RoleCheckMiddleware checks if user has the required role
func RoleCheckMiddleware(operationService service.OperationService) func(string) fiber.Handler {
	return func(operationCode string) fiber.Handler {
		return func(c *fiber.Ctx) error {
			// Get user ID from context
			userID, ok := c.Locals("user_id").(int)
			if !ok || userID == 0 {
				return c.Status(fiber.StatusUnauthorized).JSON(utils.ErrorResponse(
					"Authentication required",
					"User not authenticated",
				))
			}

			// Check if user has permission for the operation
			hasAccess, err := operationService.CheckUserAccess(c.Context(), userID, operationCode)
			if err != nil {
				return c.Status(fiber.StatusInternalServerError).JSON(utils.ErrorResponse(
					"Error checking permissions",
					err.Error(),
				))
			}

			if !hasAccess {
				return c.Status(fiber.StatusForbidden).JSON(utils.ErrorResponse(
					"Permission denied",
					"You don't have permission to perform this operation",
				))
			}

			// Continue to next handler
			return c.Next()
		}
	}
}

================
File: internal/models/access_log.go
================
package models

import "time"

// AccessLog represents a log of user access to operations
type AccessLog struct {
	ID           int       `json:"id"`
	UserID       int       `json:"user_id"`
	OperationID  int       `json:"operation_id"`
	AccessTime   time.Time `json:"access_time"`
	SearchParams string    `json:"search_params,omitempty"`
	IPAddress    string    `json:"ip_address,omitempty"`
	Status       string    `json:"status"`
}

================
File: internal/models/department.go
================
package models

import "time"

// Department represents a department in the organization
type Department struct {
	ID          int       `json:"id"`
	Name        string    `json:"name"`
	Code        string    `json:"code"`
	Description string    `json:"description,omitempty"`
	IsActive    bool      `json:"is_active"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	Users       []*User   `json:"users,omitempty"`
}

================
File: internal/models/operation.go
================
package models

import "time"

// Operation represents a system operation that can be permitted
type Operation struct {
	ID          int       `json:"id"`
	Name        string    `json:"name"`
	Code        string    `json:"code"`
	Description string    `json:"description,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

================
File: internal/models/role.go
================
package models

import "time"

// Role represents a user role with permissions
type Role struct {
	ID          int          `json:"id"`
	Name        string       `json:"name"`
	Description string       `json:"description,omitempty"`
	CreatedAt   time.Time    `json:"created_at"`
	UpdatedAt   time.Time    `json:"updated_at"`
	Operations  []*Operation `json:"operations,omitempty"`
}

// RoleOperation represents the relationship between roles and operations
type RoleOperation struct {
	RoleID      int       `json:"role_id"`
	OperationID int       `json:"operation_id"`
	CanAccess   bool      `json:"can_access"`
	CreatedAt   time.Time `json:"created_at"`
}

================
File: internal/models/user.go
================
package models

import "time"

// User represents a system user
type User struct {
	ID           int         `json:"id"`
	Username     string      `json:"username"`
	Password     string      `json:"-"` // Don't expose password
	FullName     string      `json:"full_name"`
	Email        string      `json:"email"`
	Phone        string      `json:"phone,omitempty"`
	DepartmentID int         `json:"department_id"`
	Department   *Department `json:"department,omitempty"`
	IsActive     bool        `json:"is_active"`
	LastLogin    time.Time   `json:"last_login,omitempty"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	Roles        []*Role     `json:"roles,omitempty"`
}

// UserRole represents the relationship between users and roles
type UserRole struct {
	UserID    int       `json:"user_id"`
	RoleID    int       `json:"role_id"`
	CreatedAt time.Time `json:"created_at"`
}

================
File: internal/repository/access_log_repository.go
================
package repository

import (
	"context"
	"database/sql"
	"erp-excel/internal/models"
	"fmt"
)

// AccessLogRepository interface
type AccessLogRepository interface {
	Create(ctx context.Context, log *models.AccessLog) (int, error)
	UpdateStatus(ctx context.Context, id int, status string) (bool, error)
	GetRecentLogs(ctx context.Context, limit int) ([]*models.AccessLog, error)
	GetUserLogs(ctx context.Context, userID int, limit int) ([]*models.AccessLog, error)
}

type accessLogRepository struct {
	db *sql.DB
}

// NewAccessLogRepository creates a new access log repository
func NewAccessLogRepository(db *sql.DB) AccessLogRepository {
	return &accessLogRepository{
		db: db,
	}
}

// Create adds a new access log entry
func (r *accessLogRepository) Create(ctx context.Context, log *models.AccessLog) (int, error) {
	query := `
        INSERT INTO access_logs (user_id, operation_id, access_time, search_params, ip_address, status)
        OUTPUT INSERTED.id
        VALUES (@user_id, @operation_id, @access_time, @search_params, @ip_address, @status)
    `

	var id int
	err := r.db.QueryRowContext(
		ctx,
		query,
		sql.Named("user_id", log.UserID),
		sql.Named("operation_id", log.OperationID),
		sql.Named("access_time", log.AccessTime),
		sql.Named("search_params", log.SearchParams),
		sql.Named("ip_address", log.IPAddress),
		sql.Named("status", log.Status),
	).Scan(&id)

	if err != nil {
		return 0, fmt.Errorf("error creating access log: %w", err)
	}

	return id, nil
}

// UpdateStatus updates the status of an access log
func (r *accessLogRepository) UpdateStatus(ctx context.Context, id int, status string) (bool, error) {
	query := `
        UPDATE access_logs
        SET status = @status
        WHERE id = @id
    `

	result, err := r.db.ExecContext(
		ctx,
		query,
		sql.Named("status", status),
		sql.Named("id", id),
	)

	if err != nil {
		return false, fmt.Errorf("error updating access log status: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return false, fmt.Errorf("error getting rows affected: %w", err)
	}

	return rowsAffected > 0, nil
}

// GetRecentLogs gets recent access logs
func (r *accessLogRepository) GetRecentLogs(ctx context.Context, limit int) ([]*models.AccessLog, error) {
	query := `
        SELECT l.id, l.user_id, l.operation_id, l.access_time, l.search_params, l.ip_address, l.status,
               u.username, o.name as operation_name
        FROM access_logs l
        JOIN users u ON l.user_id = u.id
        JOIN operations o ON l.operation_id = o.id
        ORDER BY l.access_time DESC
        OFFSET 0 ROWS
        FETCH NEXT @limit ROWS ONLY
    `

	rows, err := r.db.QueryContext(ctx, query, sql.Named("limit", limit))
	if err != nil {
		return nil, fmt.Errorf("error getting recent logs: %w", err)
	}
	defer rows.Close()

	var logs []*models.AccessLog
	for rows.Next() {
		var log models.AccessLog
		var username, operationName string

		err := rows.Scan(
			&log.ID,
			&log.UserID,
			&log.OperationID,
			&log.AccessTime,
			&log.SearchParams,
			&log.IPAddress,
			&log.Status,
			&username,
			&operationName,
		)
		if err != nil {
			return nil, fmt.Errorf("error scanning log: %w", err)
		}

		logs = append(logs, &log)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating logs: %w", err)
	}

	return logs, nil
}

// GetUserLogs gets access logs for a specific user
func (r *accessLogRepository) GetUserLogs(ctx context.Context, userID int, limit int) ([]*models.AccessLog, error) {
	query := `
        SELECT l.id, l.user_id, l.operation_id, l.access_time, l.search_params, l.ip_address, l.status,
               o.name as operation_name
        FROM access_logs l
        JOIN operations o ON l.operation_id = o.id
        WHERE l.user_id = @user_id
        ORDER BY l.access_time DESC
        OFFSET 0 ROWS
        FETCH NEXT @limit ROWS ONLY
    `

	rows, err := r.db.QueryContext(
		ctx,
		query,
		sql.Named("user_id", userID),
		sql.Named("limit", limit),
	)
	if err != nil {
		return nil, fmt.Errorf("error getting user logs: %w", err)
	}
	defer rows.Close()

	var logs []*models.AccessLog
	for rows.Next() {
		var log models.AccessLog
		var operationName string

		err := rows.Scan(
			&log.ID,
			&log.UserID,
			&log.OperationID,
			&log.AccessTime,
			&log.SearchParams,
			&log.IPAddress,
			&log.Status,
			&operationName,
		)
		if err != nil {
			return nil, fmt.Errorf("error scanning log: %w", err)
		}

		logs = append(logs, &log)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating logs: %w", err)
	}

	return logs, nil
}

================
File: internal/repository/department_repository.go
================
package repository

import (
	"context"
	"database/sql"
	"erp-excel/internal/models"
	"fmt"
	"time"
)

// DepartmentRepository interface
type DepartmentRepository interface {
	Create(ctx context.Context, department *models.Department) (*models.Department, error)
	GetByID(ctx context.Context, id int) (*models.Department, error)
	Update(ctx context.Context, department *models.Department) error
	Delete(ctx context.Context, id int) error
	List(ctx context.Context, limit, offset int) ([]*models.Department, error)
	Count(ctx context.Context) (int, error)
	GetUserCount(ctx context.Context, departmentID int) (int, error)
}

type departmentRepository struct {
	db *sql.DB
}

// NewDepartmentRepository creates a new department repository
func NewDepartmentRepository(db *sql.DB) DepartmentRepository {
	return &departmentRepository{
		db: db,
	}
}

// Create adds a new department
func (r *departmentRepository) Create(ctx context.Context, department *models.Department) (*models.Department, error) {
	query := `
        INSERT INTO departments (name, code, description, is_active, created_at, updated_at)
        OUTPUT INSERTED.id
        VALUES (@name, @code, @description, @is_active, @created_at, @updated_at)
    `

	var id int
	err := r.db.QueryRowContext(
		ctx,
		query,
		sql.Named("name", department.Name),
		sql.Named("code", department.Code),
		sql.Named("description", department.Description),
		sql.Named("is_active", department.IsActive),
		sql.Named("created_at", time.Now()),
		sql.Named("updated_at", time.Now()),
	).Scan(&id)

	if err != nil {
		return nil, fmt.Errorf("error creating department: %w", err)
	}

	department.ID = id
	return department, nil
}

// GetByID gets a department by ID
func (r *departmentRepository) GetByID(ctx context.Context, id int) (*models.Department, error) {
	query := `
        SELECT id, name, code, description, is_active, created_at, updated_at
        FROM departments
        WHERE id = @id
    `

	var department models.Department
	err := r.db.QueryRowContext(ctx, query, sql.Named("id", id)).Scan(
		&department.ID,
		&department.Name,
		&department.Code,
		&department.Description,
		&department.IsActive,
		&department.CreatedAt,
		&department.UpdatedAt,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("department not found: %w", err)
		}
		return nil, fmt.Errorf("error getting department: %w", err)
	}

	// Get user count for this department
	if _, err := r.GetUserCount(ctx, department.ID); err == nil {
		// Just log the error, don't fail the operation
		fmt.Printf("Error getting user count: %v\n", err)
	}

	return &department, nil
}

// Update updates a department
func (r *departmentRepository) Update(ctx context.Context, department *models.Department) error {
	query := `
        UPDATE departments
        SET name = @name,
            description = @description,
            is_active = @is_active,
            updated_at = @updated_at
        WHERE id = @id
    `

	_, err := r.db.ExecContext(
		ctx,
		query,
		sql.Named("name", department.Name),
		sql.Named("description", department.Description),
		sql.Named("is_active", department.IsActive),
		sql.Named("updated_at", time.Now()),
		sql.Named("id", department.ID),
	)

	if err != nil {
		return fmt.Errorf("error updating department: %w", err)
	}

	return nil
}

// Delete deactivates a department
func (r *departmentRepository) Delete(ctx context.Context, id int) error {
	query := `
        UPDATE departments
        SET is_active = 0,
            updated_at = @updated_at
        WHERE id = @id
    `

	_, err := r.db.ExecContext(
		ctx,
		query,
		sql.Named("updated_at", time.Now()),
		sql.Named("id", id),
	)

	if err != nil {
		return fmt.Errorf("error deleting department: %w", err)
	}

	return nil
}

// List gets a list of departments
func (r *departmentRepository) List(ctx context.Context, limit, offset int) ([]*models.Department, error) {
	query := `
        SELECT id, name, code, description, is_active, created_at, updated_at
        FROM (
            SELECT 
                id, name, code, description, is_active, created_at, updated_at,
                ROW_NUMBER() OVER (ORDER BY name) AS RowNum
            FROM departments
        ) AS DepartmentWithRowNumbers
        WHERE RowNum BETWEEN @offset + 1 AND @offset + @limit
        ORDER BY name
    `

	rows, err := r.db.QueryContext(
		ctx,
		query,
		sql.Named("limit", limit),
		sql.Named("offset", offset),
	)
	if err != nil {
		return nil, fmt.Errorf("error listing departments: %w", err)
	}
	defer rows.Close()

	var departments []*models.Department
	for rows.Next() {
		var department models.Department
		err := rows.Scan(
			&department.ID,
			&department.Name,
			&department.Code,
			&department.Description,
			&department.IsActive,
			&department.CreatedAt,
			&department.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("error scanning department: %w", err)
		}

		departments = append(departments, &department)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating departments: %w", err)
	}

	return departments, nil
}

// Count gets the total number of departments
func (r *departmentRepository) Count(ctx context.Context) (int, error) {
	var count int
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM departments").Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("error counting departments: %w", err)
	}
	return count, nil
}

// GetUserCount gets the number of users in a department
func (r *departmentRepository) GetUserCount(ctx context.Context, departmentID int) (int, error) {
	query := `
        SELECT COUNT(*) 
        FROM users 
        WHERE department_id = @department_id
    `

	var count int
	err := r.db.QueryRowContext(ctx, query, sql.Named("department_id", departmentID)).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("error counting users in department: %w", err)
	}

	return count, nil
}

================
File: internal/repository/operation_repository.go
================
package repository

import (
	"context"
	"database/sql"
	"erp-excel/internal/dto"
	"erp-excel/internal/models"
	"fmt"
)

// OperationRepository interface
type OperationRepository interface {
	GetAll(ctx context.Context) ([]*dto.OperationResponse, error)
	FindByCode(ctx context.Context, code string) (*models.Operation, error)
	GetByID(ctx context.Context, id int) (*models.Operation, error)
	LogAccess(ctx context.Context, log *models.AccessLog) (int, error)
	UpdateLogStatus(ctx context.Context, logID int, status string) (bool, error)
	GetRecentLogs(ctx context.Context, limit int) ([]*models.AccessLog, error)
}

type operationRepository struct {
	db *sql.DB
}

// NewOperationRepository creates a new operation repository
func NewOperationRepository(db *sql.DB) OperationRepository {
	return &operationRepository{
		db: db,
	}
}

// GetAll gets all operations
func (r *operationRepository) GetAll(ctx context.Context) ([]*dto.OperationResponse, error) {
	query := `
        SELECT id, name, code, description
        FROM operations
        ORDER BY name
    `

	rows, err := r.db.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("error getting operations: %w", err)
	}
	defer rows.Close()

	var operations []*dto.OperationResponse
	for rows.Next() {
		var operation dto.OperationResponse
		err := rows.Scan(
			&operation.ID,
			&operation.Name,
			&operation.Code,
			&operation.Description,
		)
		if err != nil {
			return nil, fmt.Errorf("error scanning operation: %w", err)
		}

		operations = append(operations, &operation)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating operations: %w", err)
	}

	return operations, nil
}

// FindByCode gets an operation by code
func (r *operationRepository) FindByCode(ctx context.Context, code string) (*models.Operation, error) {
	query := `
        SELECT id, name, code, description, created_at, updated_at
        FROM operations
        WHERE code = @code
    `

	var operation models.Operation
	err := r.db.QueryRowContext(ctx, query, sql.Named("code", code)).Scan(
		&operation.ID,
		&operation.Name,
		&operation.Code,
		&operation.Description,
		&operation.CreatedAt,
		&operation.UpdatedAt,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("operation not found: %w", err)
		}
		return nil, fmt.Errorf("error getting operation: %w", err)
	}

	return &operation, nil
}

// GetByID gets an operation by ID
func (r *operationRepository) GetByID(ctx context.Context, id int) (*models.Operation, error) {
	query := `
        SELECT id, name, code, description, created_at, updated_at
        FROM operations
        WHERE id = @id
    `

	var operation models.Operation
	err := r.db.QueryRowContext(ctx, query, sql.Named("id", id)).Scan(
		&operation.ID,
		&operation.Name,
		&operation.Code,
		&operation.Description,
		&operation.CreatedAt,
		&operation.UpdatedAt,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("operation not found: %w", err)
		}
		return nil, fmt.Errorf("error getting operation: %w", err)
	}

	return &operation, nil
}

// LogAccess logs access to an operation
func (r *operationRepository) LogAccess(ctx context.Context, log *models.AccessLog) (int, error) {
	query := `
        INSERT INTO access_logs (user_id, operation_id, access_time, search_params, ip_address, status)
        OUTPUT INSERTED.id
        VALUES (@user_id, @operation_id, @access_time, @search_params, @ip_address, @status)
    `

	var id int
	err := r.db.QueryRowContext(
		ctx,
		query,
		sql.Named("user_id", log.UserID),
		sql.Named("operation_id", log.OperationID),
		sql.Named("access_time", log.AccessTime),
		sql.Named("search_params", log.SearchParams),
		sql.Named("ip_address", log.IPAddress),
		sql.Named("status", log.Status),
	).Scan(&id)

	if err != nil {
		return 0, fmt.Errorf("error logging access: %w", err)
	}

	return id, nil
}

// UpdateLogStatus updates the status of an access log
func (r *operationRepository) UpdateLogStatus(ctx context.Context, logID int, status string) (bool, error) {
	query := `
        UPDATE access_logs
        SET status = @status
        WHERE id = @id
    `

	result, err := r.db.ExecContext(
		ctx,
		query,
		sql.Named("status", status),
		sql.Named("id", logID),
	)

	if err != nil {
		return false, fmt.Errorf("error updating log status: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return false, fmt.Errorf("error getting rows affected: %w", err)
	}

	return rowsAffected > 0, nil
}

// GetRecentLogs gets recent access logs
func (r *operationRepository) GetRecentLogs(ctx context.Context, limit int) ([]*models.AccessLog, error) {
	query := `
        SELECT *
        FROM (
            SELECT 
                l.id, 
                l.user_id, 
                l.operation_id, 
                l.access_time, 
                l.search_params, 
                l.ip_address, 
                l.status,
                u.username, 
                o.name as operation_name,
                ROW_NUMBER() OVER (ORDER BY l.access_time DESC) AS RowNum
            FROM access_logs l
            JOIN users u ON l.user_id = u.id
            JOIN operations o ON l.operation_id = o.id
        ) AS LogsWithRowNumbers
        WHERE RowNum BETWEEN 1 AND @limit
    `

	rows, err := r.db.QueryContext(
		ctx,
		query,
		sql.Named("limit", limit),
	)
	if err != nil {
		return nil, fmt.Errorf("error getting recent logs: %w", err)
	}
	defer rows.Close()

	var logs []*models.AccessLog
	for rows.Next() {
		var log models.AccessLog
		var username, operationName string
		var rowNum int

		err := rows.Scan(
			&log.ID,
			&log.UserID,
			&log.OperationID,
			&log.AccessTime,
			&log.SearchParams,
			&log.IPAddress,
			&log.Status,
			&username,
			&operationName,
			&rowNum,
		)
		if err != nil {
			return nil, fmt.Errorf("error scanning log: %w", err)
		}

		logs = append(logs, &log)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating logs: %w", err)
	}

	return logs, nil
}

================
File: internal/repository/report_repository.go
================
package repository

import (
	"context"
	"database/sql"
	"erp-excel/internal/dto"
	"fmt"
	"log"
	"time"
)

// InventoryRepository defines the interface for inventory-related database queries
type InventoryRepository interface {
	// GetInventoryReport retrieves inventory report data based on specified criteria
	GetInventoryReport(
		ctx context.Context,
		fromDate time.Time,
		toDate time.Time,
		departmentID int,
	) ([]dto.InventoryReportItem, error)
}

// inventoryRepository implements InventoryRepository
type inventoryRepository struct {
	erpDB *sql.DB
}

// NewInventoryRepository creates a new instance of InventoryRepository
func NewInventoryRepository(erpDB *sql.DB) InventoryRepository {
	return &inventoryRepository{
		erpDB: erpDB,
	}
}

// GetInventoryReport retrieves detailed inventory report
func (r *inventoryRepository) GetInventoryReport(
	ctx context.Context,
	fromDate time.Time,
	toDate time.Time,
	departmentID int, // departmentID not used in query, consider removing if not needed or add to query
) ([]dto.InventoryReportItem, error) {
	_, err := r.erpDB.ExecContext(ctx, "USE Leader")
	if err != nil {
		return nil, fmt.Errorf("error switching database: %w", err)
	}

	query := `
    SELECT DISTINCT
        CONVERT(VARCHAR(10), CONVERT(DATETIME, TG042), 103) AS [Ngay CT],
        TG001 + '-' + TG002 AS [Ma Don ban hang],
        TG007 AS [KH],
        ISNULL(TA001 + '-' + TA002, '') AS [Ma phieu ket so],
        CASE
            WHEN TG011 = 'VND' THEN REPLACE(CONVERT(VARCHAR, CONVERT(MONEY, (ISNULL(TG013, 0) + ISNULL(TG025, 0))), 1), '.00', '')
            ELSE CONVERT(VARCHAR, CONVERT(MONEY, (ISNULL(TG013, 0) + ISNULL(TG025, 0))), 1)
        END AS [Nguyen te],
        REPLACE(CONVERT(VARCHAR, CONVERT(MONEY, (ISNULL(TG045, 0) + ISNULL(TG046, 0))), 1), '.00', '') AS [Noi te],
        ISNULL(TD001 + '-' + TD002 + '-' + RIGHT('0' + TD003, 4), '') AS [Ma Don hang chi tiet],
        ISNULL(TA036, '') AS [Hoa don],
        ISNULL(TG020, '') AS [Ghi chu]
    FROM
        COPTG WITH (NOLOCK)
    LEFT JOIN
        ACRTA WITH (NOLOCK) ON TA001 = TG001 AND TA002 = TG002
    LEFT JOIN
        COPTD WITH (NOLOCK) ON TD001 = TG001 AND TD002 = TG002
    WHERE
        TG023 <> 'V'
    AND TG042 BETWEEN @FromDate AND @ToDate
    `
	log.Printf("Executing query for FromDate: %v, ToDate: %v", fromDate, toDate)

	rows, err := r.erpDB.QueryContext(
		ctx,
		query,
		sql.Named("FromDate", fromDate),
		sql.Named("ToDate", toDate),
		// sql.Named("DepartmentID", departmentID), // Uncomment and use if needed in SQL query
	)
	if err != nil {
		return nil, fmt.Errorf("error querying inventory data: %w", err)
	}
	defer rows.Close()

	var items []dto.InventoryReportItem
	for rows.Next() {
		var item dto.InventoryReportItem
		if err := rows.Scan(
			&item.NgayCT,
			&item.MaDonBanHang,
			&item.KhachHang,
			&item.MaPhieuKetSo,
			&item.NguyenTe,
			&item.NoiTe,
			&item.MaDonHangChiTiet,
			&item.HoaDon,
			&item.GhiChu,
		); err != nil {
			return nil, fmt.Errorf("error scanning inventory data: %w", err)
		}
		items = append(items, item)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating inventory data: %w", err)
	}

	return items, nil
}

================
File: internal/repository/role_repository.go
================
package repository

import (
	"context"
	"database/sql"
	"erp-excel/internal/models"
	"fmt"
	"time"
)

// RoleRepository interface
type RoleRepository interface {
	Create(ctx context.Context, role *models.Role) (*models.Role, error)
	GetByID(ctx context.Context, id int) (*models.Role, error)
	Update(ctx context.Context, role *models.Role) error
	Delete(ctx context.Context, id int) error
	List(ctx context.Context, limit, offset int) ([]*models.Role, error)
	Count(ctx context.Context) (int, error)
	GetOperations(ctx context.Context, roleID int) ([]*models.Operation, error)
	AssignOperations(ctx context.Context, roleID int, operationIDs []int) error
	RemoveOperations(ctx context.Context, roleID int, operationIDs []int) error
	CheckUserOperationAccess(ctx context.Context, userID int, operationID int) (bool, error)
}

type roleRepository struct {
	db *sql.DB
}

// NewRoleRepository creates a new role repository
func NewRoleRepository(db *sql.DB) RoleRepository {
	return &roleRepository{
		db: db,
	}
}

// Create adds a new role
func (r *roleRepository) Create(ctx context.Context, role *models.Role) (*models.Role, error) {
	query := `  
        INSERT INTO roles (name, description, created_at, updated_at)  
        OUTPUT INSERTED.id  
        VALUES (@name, @description, @created_at, @updated_at)  
    `

	var id int
	err := r.db.QueryRowContext(
		ctx,
		query,
		sql.Named("name", role.Name),
		sql.Named("description", role.Description),
		sql.Named("created_at", time.Now()),
		sql.Named("updated_at", time.Now()),
	).Scan(&id)

	if err != nil {
		return nil, fmt.Errorf("error creating role: %w", err)
	}

	role.ID = id
	return role, nil
}

// GetByID gets a role by ID
func (r *roleRepository) GetByID(ctx context.Context, id int) (*models.Role, error) {
	query := `  
        SELECT id, name, description, created_at, updated_at  
        FROM roles  
        WHERE id = @id  
    `

	var role models.Role
	err := r.db.QueryRowContext(ctx, query, sql.Named("id", id)).Scan(
		&role.ID,
		&role.Name,
		&role.Description,
		&role.CreatedAt,
		&role.UpdatedAt,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("role not found: %w", err)
		}
		return nil, fmt.Errorf("error getting role: %w", err)
	}

	// Get operations for this role
	operations, err := r.GetOperations(ctx, role.ID)
	if err != nil {
		return nil, fmt.Errorf("error getting role operations: %w", err)
	}
	role.Operations = operations

	return &role, nil
}

// Update updates a role
func (r *roleRepository) Update(ctx context.Context, role *models.Role) error {
	query := `  
        UPDATE roles  
        SET name = @name,  
            description = @description,  
            updated_at = @updated_at  
        WHERE id = @id  
    `

	_, err := r.db.ExecContext(
		ctx,
		query,
		sql.Named("name", role.Name),
		sql.Named("description", role.Description),
		sql.Named("updated_at", time.Now()),
		sql.Named("id", role.ID),
	)

	if err != nil {
		return fmt.Errorf("error updating role: %w", err)
	}

	return nil
}

// Delete deletes a role
func (r *roleRepository) Delete(ctx context.Context, id int) error {
	// Start a transaction
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("error beginning transaction: %w", err)
	}
	defer tx.Rollback()

	// Delete role_operations first
	_, err = tx.ExecContext(
		ctx,
		"DELETE FROM role_operations WHERE role_id = @role_id",
		sql.Named("role_id", id),
	)
	if err != nil {
		return fmt.Errorf("error deleting role operations: %w", err)
	}

	// Delete user_roles
	_, err = tx.ExecContext(
		ctx,
		"DELETE FROM user_roles WHERE role_id = @role_id",
		sql.Named("role_id", id),
	)
	if err != nil {
		return fmt.Errorf("error deleting user roles: %w", err)
	}

	// Delete role
	_, err = tx.ExecContext(
		ctx,
		"DELETE FROM roles WHERE id = @id",
		sql.Named("id", id),
	)
	if err != nil {
		return fmt.Errorf("error deleting role: %w", err)
	}

	// Commit transaction
	if err := tx.Commit(); err != nil {
		return fmt.Errorf("error committing transaction: %w", err)
	}

	return nil
}

// List gets a list of roles
func (r *roleRepository) List(ctx context.Context, limit, offset int) ([]*models.Role, error) {
	query := `  
        SELECT *
        FROM (
            SELECT 
                id, 
                name, 
                description, 
                created_at, 
                updated_at,
                ROW_NUMBER() OVER (ORDER BY name) AS RowNum
            FROM roles
        ) AS RolesWithRowNumbers
        WHERE RowNum BETWEEN @offset + 1 AND @offset + @limit
    `

	rows, err := r.db.QueryContext(
		ctx,
		query,
		sql.Named("limit", limit),
		sql.Named("offset", offset),
	)
	if err != nil {
		return nil, fmt.Errorf("error listing roles: %w", err)
	}
	defer rows.Close()

	var roles []*models.Role
	for rows.Next() {
		var role models.Role
		var rowNum int // Thêm biến để scan row number

		err := rows.Scan(
			&role.ID,
			&role.Name,
			&role.Description,
			&role.CreatedAt,
			&role.UpdatedAt,
			&rowNum, // Scan row number
		)
		if err != nil {
			return nil, fmt.Errorf("error scanning role: %w", err)
		}

		roles = append(roles, &role)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating roles: %w", err)
	}

	return roles, nil
}

// Count gets the total number of roles
func (r *roleRepository) Count(ctx context.Context) (int, error) {
	var count int
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM roles").Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("error counting roles: %w", err)
	}
	return count, nil
}

// GetOperations gets operations assigned to a role
func (r *roleRepository) GetOperations(ctx context.Context, roleID int) ([]*models.Operation, error) {
	query := `
        SELECT o.id, o.name, o.code, o.description, o.created_at, o.updated_at
        FROM operations o
        JOIN role_operations ro ON o.id = ro.operation_id
        WHERE ro.role_id = @role_id AND ro.can_access = 1
        ORDER BY o.name
    `

	rows, err := r.db.QueryContext(ctx, query, sql.Named("role_id", roleID))
	if err != nil {
		return nil, fmt.Errorf("error getting role operations: %w", err)
	}
	defer rows.Close()

	var operations []*models.Operation
	for rows.Next() {
		var operation models.Operation
		err := rows.Scan(
			&operation.ID,
			&operation.Name,
			&operation.Code,
			&operation.Description,
			&operation.CreatedAt,
			&operation.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("error scanning operation: %w", err)
		}

		operations = append(operations, &operation)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating operations: %w", err)
	}

	return operations, nil
}

// AssignOperations assigns operations to a role
func (r *roleRepository) AssignOperations(ctx context.Context, roleID int, operationIDs []int) error {
	// Start a transaction
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("error beginning transaction: %w", err)
	}
	defer tx.Rollback()

	// Delete existing operations first
	_, err = tx.ExecContext(
		ctx,
		"DELETE FROM role_operations WHERE role_id = @role_id",
		sql.Named("role_id", roleID),
	)
	if err != nil {
		return fmt.Errorf("error deleting existing operations: %w", err)
	}

	// Insert new operations
	for _, operationID := range operationIDs {
		_, err = tx.ExecContext(
			ctx,
			"INSERT INTO role_operations (role_id, operation_id, can_access, created_at) VALUES (@role_id, @operation_id, 1, @created_at)",
			sql.Named("role_id", roleID),
			sql.Named("operation_id", operationID),
			sql.Named("created_at", time.Now()),
		)
		if err != nil {
			return fmt.Errorf("error assigning operation: %w", err)
		}
	}

	// Commit transaction
	if err := tx.Commit(); err != nil {
		return fmt.Errorf("error committing transaction: %w", err)
	}

	return nil
}

// RemoveOperations removes operations from a role
func (r *roleRepository) RemoveOperations(ctx context.Context, roleID int, operationIDs []int) error {
	query := `
        DELETE FROM role_operations
        WHERE role_id = @role_id AND operation_id IN (
    `

	// Build the IN clause with named parameters
	params := []interface{}{sql.Named("role_id", roleID)}
	for i, operationID := range operationIDs {
		if i > 0 {
			query += ", "
		}
		paramName := fmt.Sprintf("operation_id_%d", i)
		query += "@" + paramName
		params = append(params, sql.Named(paramName, operationID))
	}
	query += ")"

	// Execute the query
	_, err := r.db.ExecContext(ctx, query, params...)
	if err != nil {
		return fmt.Errorf("error removing operations: %w", err)
	}

	return nil
}

// CheckUserOperationAccess checks if a user has access to an operation
func (r *roleRepository) CheckUserOperationAccess(ctx context.Context, userID int, operationID int) (bool, error) {
	query := `
        SELECT COUNT(*) 
        FROM user_roles ur
        JOIN role_operations ro ON ur.role_id = ro.role_id
        WHERE ur.user_id = @user_id 
          AND ro.operation_id = @operation_id 
          AND ro.can_access = 1
    `

	var count int
	err := r.db.QueryRowContext(
		ctx,
		query,
		sql.Named("user_id", userID),
		sql.Named("operation_id", operationID),
	).Scan(&count)

	if err != nil {
		return false, fmt.Errorf("error checking operation access: %w", err)
	}

	return count > 0, nil
}

================
File: internal/repository/user_repository.go
================
package repository

import (
	"context"
	"database/sql"
	"erp-excel/internal/models"
	"fmt"
	"time"
)

// UserRepository interface
type UserRepository interface {
	Create(ctx context.Context, user *models.User) (*models.User, error)
	GetByID(ctx context.Context, id int) (*models.User, error)
	GetByUsername(ctx context.Context, username string) (*models.User, error)
	Update(ctx context.Context, user *models.User) error
	UpdatePassword(ctx context.Context, userID int, hashedPassword string) error
	Delete(ctx context.Context, id int) error
	List(ctx context.Context, limit, offset int) ([]*models.User, error)
	Count(ctx context.Context) (int, error)
	GetUserRoles(ctx context.Context, userID int) ([]*models.Role, error)
	AssignRoles(ctx context.Context, userID int, roleIDs []int) error
	RemoveRoles(ctx context.Context, userID int, roleIDs []int) error
	UpdateLastLogin(ctx context.Context, userID int) error
}

type userRepository struct {
	db *sql.DB
}

// NewUserRepository creates a new user repository
func NewUserRepository(db *sql.DB) UserRepository {
	return &userRepository{
		db: db,
	}
}

// Create adds a new user to the database
func (r *userRepository) Create(ctx context.Context, user *models.User) (*models.User, error) {
	query := `
        INSERT INTO users (username, password, full_name, email, phone, department_id, is_active, created_at, updated_at)
        OUTPUT INSERTED.id
        VALUES (@username, @password, @full_name, @email, @phone, @department_id, @is_active, @created_at, @updated_at)
    `

	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("error preparing statement: %w", err)
	}
	defer stmt.Close()

	var id int
	err = stmt.QueryRowContext(
		ctx,
		sql.Named("username", user.Username),
		sql.Named("password", user.Password),
		sql.Named("full_name", user.FullName),
		sql.Named("email", user.Email),
		sql.Named("phone", user.Phone),
		sql.Named("department_id", user.DepartmentID),
		sql.Named("is_active", user.IsActive),
		sql.Named("created_at", time.Now()),
		sql.Named("updated_at", time.Now()),
	).Scan(&id)

	if err != nil {
		return nil, fmt.Errorf("error creating user: %w", err)
	}

	user.ID = id
	return user, nil
}

// GetByID gets a user by ID
func (r *userRepository) GetByID(ctx context.Context, id int) (*models.User, error) {
	query := `
        SELECT u.id, u.username, u.password, u.full_name, u.email, u.phone, u.department_id, 
               u.is_active, u.last_login, u.created_at, u.updated_at,
               d.name as department_name
        FROM users u
        LEFT JOIN departments d ON u.department_id = d.id
        WHERE u.id = @id
    `

	var user models.User
	var department models.Department
	var lastLogin sql.NullTime

	err := r.db.QueryRowContext(ctx, query, sql.Named("id", id)).Scan(
		&user.ID,
		&user.Username,
		&user.Password,
		&user.FullName,
		&user.Email,
		&user.Phone,
		&user.DepartmentID,
		&user.IsActive,
		&lastLogin,
		&user.CreatedAt,
		&user.UpdatedAt,
		&department.Name,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user not found: %w", err)
		}
		return nil, fmt.Errorf("error getting user: %w", err)
	}

	if lastLogin.Valid {
		user.LastLogin = lastLogin.Time
	}

	department.ID = user.DepartmentID
	user.Department = &department

	// Get user roles
	roles, err := r.GetUserRoles(ctx, user.ID)
	if err != nil {
		return nil, fmt.Errorf("error getting user roles: %w", err)
	}
	user.Roles = roles

	return &user, nil
}

// GetByUsername gets a user by username
func (r *userRepository) GetByUsername(ctx context.Context, username string) (*models.User, error) {
	query := `
        SELECT u.id, u.username, u.password, u.full_name, u.email, u.phone, u.department_id, 
               u.is_active, u.last_login, u.created_at, u.updated_at,
               d.name as department_name
        FROM users u
        LEFT JOIN departments d ON u.department_id = d.id
        WHERE u.username = @username
    `

	var user models.User
	var department models.Department
	var lastLogin sql.NullTime

	err := r.db.QueryRowContext(ctx, query, sql.Named("username", username)).Scan(
		&user.ID,
		&user.Username,
		&user.Password,
		&user.FullName,
		&user.Email,
		&user.Phone,
		&user.DepartmentID,
		&user.IsActive,
		&lastLogin,
		&user.CreatedAt,
		&user.UpdatedAt,
		&department.Name,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user not found: %w", err)
		}
		return nil, fmt.Errorf("error getting user: %w", err)
	}

	if lastLogin.Valid {
		user.LastLogin = lastLogin.Time
	}

	department.ID = user.DepartmentID
	user.Department = &department

	return &user, nil
}

// Update updates a user
func (r *userRepository) Update(ctx context.Context, user *models.User) error {
	query := `
        UPDATE users
        SET full_name = @full_name,
            email = @email,
            phone = @phone,
            department_id = @department_id,
            is_active = @is_active,
            updated_at = @updated_at
        WHERE id = @id
    `

	_, err := r.db.ExecContext(
		ctx,
		query,
		sql.Named("full_name", user.FullName),
		sql.Named("email", user.Email),
		sql.Named("phone", user.Phone),
		sql.Named("department_id", user.DepartmentID),
		sql.Named("is_active", user.IsActive),
		sql.Named("updated_at", time.Now()),
		sql.Named("id", user.ID),
	)

	if err != nil {
		return fmt.Errorf("error updating user: %w", err)
	}

	return nil
}

// UpdatePassword updates a user's password
func (r *userRepository) UpdatePassword(ctx context.Context, userID int, hashedPassword string) error {
	query := `
        UPDATE users
        SET password = @password,
            updated_at = @updated_at
        WHERE id = @id
    `

	_, err := r.db.ExecContext(
		ctx,
		query,
		sql.Named("password", hashedPassword),
		sql.Named("updated_at", time.Now()),
		sql.Named("id", userID),
	)

	if err != nil {
		return fmt.Errorf("error updating password: %w", err)
	}

	return nil
}

// Delete soft deletes a user
func (r *userRepository) Delete(ctx context.Context, id int) error {
	query := `
        UPDATE users
        SET is_active = 0
        WHERE id = @id
    `

	_, err := r.db.ExecContext(ctx, query, sql.Named("id", id))
	if err != nil {
		return fmt.Errorf("error deleting user: %w", err)
	}

	return nil
}

// List gets a list of users
func (r *userRepository) List(ctx context.Context, limit, offset int) ([]*models.User, error) {
	query := `
        SELECT *
        FROM (
            SELECT 
                u.id, 
                u.username, 
                u.full_name, 
                u.email, 
                u.phone, 
                u.department_id, 
                u.is_active, 
                u.last_login, 
                u.created_at, 
                u.updated_at,
                d.name as department_name,
                ROW_NUMBER() OVER (ORDER BY u.id) AS RowNum
            FROM users u
            LEFT JOIN departments d ON u.department_id = d.id
        ) AS UsersWithRowNumbers
        WHERE RowNum BETWEEN @offset + 1 AND @offset + @limit
    `

	rows, err := r.db.QueryContext(
		ctx,
		query,
		sql.Named("limit", limit),
		sql.Named("offset", offset),
	)
	if err != nil {
		return nil, fmt.Errorf("error listing users: %w", err)
	}
	defer rows.Close()

	var users []*models.User
	for rows.Next() {
		var user models.User
		var department models.Department
		var lastLogin sql.NullTime
		var rowNum int // Thêm biến để scan row number

		err := rows.Scan(
			&user.ID,
			&user.Username,
			&user.FullName,
			&user.Email,
			&user.Phone,
			&user.DepartmentID,
			&user.IsActive,
			&lastLogin,
			&user.CreatedAt,
			&user.UpdatedAt,
			&department.Name,
			&rowNum, // Scan row number
		)
		if err != nil {
			return nil, fmt.Errorf("error scanning user: %w", err)
		}

		if lastLogin.Valid {
			user.LastLogin = lastLogin.Time
		}

		department.ID = user.DepartmentID
		user.Department = &department

		users = append(users, &user)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating users: %w", err)
	}

	return users, nil
}

// Count gets the total number of users
func (r *userRepository) Count(ctx context.Context) (int, error) {
	var count int
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM users").Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("error counting users: %w", err)
	}
	return count, nil
}

// GetUserRoles gets a user's roles
func (r *userRepository) GetUserRoles(ctx context.Context, userID int) ([]*models.Role, error) {
	query := `
        SELECT r.id, r.name, r.description
        FROM roles r
        JOIN user_roles ur ON r.id = ur.role_id
        WHERE ur.user_id = @user_id
    `

	rows, err := r.db.QueryContext(ctx, query, sql.Named("user_id", userID))
	if err != nil {
		return nil, fmt.Errorf("error getting user roles: %w", err)
	}
	defer rows.Close()

	var roles []*models.Role
	for rows.Next() {
		var role models.Role
		err := rows.Scan(&role.ID, &role.Name, &role.Description)
		if err != nil {
			return nil, fmt.Errorf("error scanning role: %w", err)
		}
		roles = append(roles, &role)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating roles: %w", err)
	}

	return roles, nil
}

// AssignRoles assigns roles to a user
func (r *userRepository) AssignRoles(ctx context.Context, userID int, roleIDs []int) error {
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("error beginning transaction: %w", err)
	}
	defer tx.Rollback()

	// Delete existing roles first
	_, err = tx.ExecContext(
		ctx,
		"DELETE FROM user_roles WHERE user_id = @user_id",
		sql.Named("user_id", userID),
	)
	if err != nil {
		return fmt.Errorf("error deleting existing roles: %w", err)
	}

	// Insert new roles
	for _, roleID := range roleIDs {
		_, err = tx.ExecContext(
			ctx,
			"INSERT INTO user_roles (user_id, role_id, created_at) VALUES (@user_id, @role_id, @created_at)",
			sql.Named("user_id", userID),
			sql.Named("role_id", roleID),
			sql.Named("created_at", time.Now()),
		)
		if err != nil {
			return fmt.Errorf("error assigning role: %w", err)
		}
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("error committing transaction: %w", err)
	}

	return nil
}

// RemoveRoles removes roles from a user
func (r *userRepository) RemoveRoles(ctx context.Context, userID int, roleIDs []int) error {
	query := `
        DELETE FROM user_roles
        WHERE user_id = @user_id AND role_id IN (
    `

	params := []interface{}{sql.Named("user_id", userID)}
	for i, roleID := range roleIDs {
		if i > 0 {
			query += ", "
		}
		paramName := fmt.Sprintf("role_id_%d", i)
		query += "@" + paramName
		params = append(params, sql.Named(paramName, roleID))
	}
	query += ")"

	_, err := r.db.ExecContext(ctx, query, params...)
	if err != nil {
		return fmt.Errorf("error removing roles: %w", err)
	}

	return nil
}

// UpdateLastLogin updates a user's last login time
func (r *userRepository) UpdateLastLogin(ctx context.Context, userID int) error {
	query := `
        UPDATE users
        SET last_login = @last_login
        WHERE id = @id
    `

	_, err := r.db.ExecContext(
		ctx,
		query,
		sql.Named("last_login", time.Now()),
		sql.Named("id", userID),
	)

	if err != nil {
		return fmt.Errorf("error updating last login: %w", err)
	}

	return nil
}

================
File: internal/service/auth_service.go
================
package service

import (
	"context"
	"erp-excel/config"
	"erp-excel/internal/dto"
	"erp-excel/internal/models"
	"erp-excel/internal/repository"
	"erp-excel/internal/utils"
	"errors"
	"fmt"
	"time"

	"github.com/golang-jwt/jwt/v4"
)

// AuthService interface
type AuthService interface {
	Login(ctx context.Context, req dto.LoginRequest) (*dto.LoginResponse, error)
	ValidateToken(tokenString string) (*dto.TokenClaims, error)
	GenerateToken(user *models.User) (string, error)
	GetUserProfile(ctx context.Context, userID int) (*dto.UserResponse, error)
}

type authService struct {
	userRepo repository.UserRepository
	config   *config.Config
}

// NewAuthService creates a new auth service
func NewAuthService(userRepo repository.UserRepository, config *config.Config) AuthService {
	return &authService{
		userRepo: userRepo,
		config:   config,
	}
}

// Login authenticates a user
func (s *authService) Login(ctx context.Context, req dto.LoginRequest) (*dto.LoginResponse, error) {
	// Get user by username
	user, err := s.userRepo.GetByUsername(ctx, req.Username)
	if err != nil {
		return nil, errors.New("invalid username or password")
	}

	// Verify password
	if !utils.CheckPasswordHash(req.Password, user.Password) {
		return nil, errors.New("invalid username or password")
	}

	// Check if user is active
	if !user.IsActive {
		return nil, errors.New("account is disabled")
	}

	// Update last login time
	if err := s.userRepo.UpdateLastLogin(ctx, user.ID); err != nil {
		// Just log this error, don't fail login
		fmt.Printf("Error updating last login: %v\n", err)
	}

	// Generate JWT token
	token, err := s.GenerateToken(user)
	if err != nil {
		return nil, fmt.Errorf("error generating token: %w", err)
	}

	// Get user roles for response
	roles, err := s.userRepo.GetUserRoles(ctx, user.ID)
	if err != nil {
		return nil, fmt.Errorf("error getting user roles: %w", err)
	}
	user.Roles = roles

	// Create response
	roleNames := make([]string, 0, len(roles))
	for _, role := range roles {
		roleNames = append(roleNames, role.Name)
	}

	userResp := &dto.UserResponse{
		ID:           user.ID,
		Username:     user.Username,
		FullName:     user.FullName,
		Email:        user.Email,
		Phone:        user.Phone,
		DepartmentID: user.DepartmentID,
		Department:   user.Department.Name,
		IsActive:     user.IsActive,
		CreatedAt:    user.CreatedAt,
		Roles:        roleNames,
	}

	return &dto.LoginResponse{
		User:  userResp,
		Token: token,
	}, nil
}

// ValidateToken validates a JWT token
func (s *authService) ValidateToken(tokenString string) (*dto.TokenClaims, error) {
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		// Validate signing method
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return []byte(s.config.JWT.Secret), nil
	})

	if err != nil {
		return nil, err
	}

	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok || !token.Valid {
		return nil, errors.New("invalid token")
	}

	return &dto.TokenClaims{
		UserID:       int(claims["user_id"].(float64)),
		Username:     claims["username"].(string),
		DepartmentID: int(claims["department_id"].(float64)),
		Exp:          int64(claims["exp"].(float64)),
	}, nil
}

// GenerateToken generates a JWT token for a user
func (s *authService) GenerateToken(user *models.User) (string, error) {
	// Set expiration time
	expirationTime := time.Now().Add(s.config.GetJWTExpiry())

	// Create claims
	claims := jwt.MapClaims{
		"user_id":       user.ID,
		"username":      user.Username,
		"department_id": user.DepartmentID,
		"exp":           expirationTime.Unix(),
		"iat":           time.Now().Unix(),
	}

	// Create token
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	// Sign token with secret
	tokenString, err := token.SignedString([]byte(s.config.JWT.Secret))
	if err != nil {
		return "", err
	}

	return tokenString, nil
}

// GetUserProfile retrieves the user profile by ID
func (s *authService) GetUserProfile(ctx context.Context, userID int) (*dto.UserResponse, error) {
	// Get user by ID
	user, err := s.userRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("error getting user: %w", err)
	}

	// Get user roles for response
	roles, err := s.userRepo.GetUserRoles(ctx, user.ID)
	if err != nil {
		return nil, fmt.Errorf("error getting user roles: %w", err)
	}

	// Extract role names
	roleNames := make([]string, 0, len(roles))
	for _, role := range roles {
		roleNames = append(roleNames, role.Name)
	}

	departmentName := ""
	if user.Department != nil {
		departmentName = user.Department.Name
	}

	// Return user response DTO
	return &dto.UserResponse{
		ID:           user.ID,
		Username:     user.Username,
		FullName:     user.FullName,
		Email:        user.Email,
		Phone:        user.Phone,
		DepartmentID: user.DepartmentID,
		Department:   departmentName,
		IsActive:     user.IsActive,
		CreatedAt:    user.CreatedAt,
		Roles:        roleNames,
	}, nil
}

================
File: internal/service/department_service.go
================
package service

import (
	"context"
	"erp-excel/internal/dto"
	"erp-excel/internal/models"
	"erp-excel/internal/repository"
	"errors"
	"fmt"
)

// DepartmentService interface
type DepartmentService interface {
	CreateDepartment(ctx context.Context, request dto.CreateDepartmentRequest) (*dto.DepartmentResponse, error)
	GetDepartmentByID(ctx context.Context, id int) (*dto.DepartmentResponse, error)
	UpdateDepartment(ctx context.Context, id int, request dto.UpdateDepartmentRequest) (*dto.DepartmentResponse, error)
	DeleteDepartment(ctx context.Context, id int) error
	GetAllDepartments(ctx context.Context, limit, offset int) ([]*dto.DepartmentResponse, error)
	CountDepartments(ctx context.Context) (int, error)
}

type departmentService struct {
	departmentRepo repository.DepartmentRepository
}

// NewDepartmentService creates a new department service
func NewDepartmentService(departmentRepo repository.DepartmentRepository) DepartmentService {
	return &departmentService{
		departmentRepo: departmentRepo,
	}
}

// CreateDepartment creates a new department
func (s *departmentService) CreateDepartment(ctx context.Context, request dto.CreateDepartmentRequest) (*dto.DepartmentResponse, error) {
	// Create department model
	isActive := true
	if request.IsActive != nil {
		isActive = *request.IsActive
	}

	department := &models.Department{
		Name:        request.Name,
		Code:        request.Code,
		Description: request.Description,
		IsActive:    isActive,
	}

	// Save to database
	createdDepartment, err := s.departmentRepo.Create(ctx, department)
	if err != nil {
		return nil, fmt.Errorf("error creating department: %w", err)
	}

	// Return response
	return &dto.DepartmentResponse{
		ID:          createdDepartment.ID,
		Name:        createdDepartment.Name,
		Code:        createdDepartment.Code,
		Description: createdDepartment.Description,
		IsActive:    createdDepartment.IsActive,
	}, nil
}

// GetDepartmentByID gets a department by ID
func (s *departmentService) GetDepartmentByID(ctx context.Context, id int) (*dto.DepartmentResponse, error) {
	department, err := s.departmentRepo.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("error getting department: %w", err)
	}

	// Get user count
	userCount, err := s.departmentRepo.GetUserCount(ctx, department.ID)
	if err != nil {
		// Log the error but continue
		fmt.Printf("Error getting user count: %v\n", err)
		userCount = 0
	}

	return &dto.DepartmentResponse{
		ID:          department.ID,
		Name:        department.Name,
		Code:        department.Code,
		Description: department.Description,
		IsActive:    department.IsActive,
		UserCount:   userCount,
	}, nil
}

// UpdateDepartment updates a department
func (s *departmentService) UpdateDepartment(ctx context.Context, id int, request dto.UpdateDepartmentRequest) (*dto.DepartmentResponse, error) {
	// Get existing department
	department, err := s.departmentRepo.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("error getting department: %w", err)
	}

	// Update fields if provided
	if request.Name != "" {
		department.Name = request.Name
	}

	if request.Description != "" {
		department.Description = request.Description
	}

	if request.IsActive != nil {
		department.IsActive = *request.IsActive
	}

	// Save to database
	if err := s.departmentRepo.Update(ctx, department); err != nil {
		return nil, fmt.Errorf("error updating department: %w", err)
	}

	// Get user count
	userCount, err := s.departmentRepo.GetUserCount(ctx, department.ID)
	if err != nil {
		// Log the error but continue
		fmt.Printf("Error getting user count: %v\n", err)
		userCount = 0
	}

	// Return response
	return &dto.DepartmentResponse{
		ID:          department.ID,
		Name:        department.Name,
		Code:        department.Code,
		Description: department.Description,
		IsActive:    department.IsActive,
		UserCount:   userCount,
	}, nil
}

// DeleteDepartment deletes a department
func (s *departmentService) DeleteDepartment(ctx context.Context, id int) error {
	// Check if department has users
	userCount, err := s.departmentRepo.GetUserCount(ctx, id)
	if err != nil {
		return fmt.Errorf("error checking department users: %w", err)
	}

	if userCount > 0 {
		return errors.New("cannot delete department with assigned users")
	}

	// Delete department
	if err := s.departmentRepo.Delete(ctx, id); err != nil {
		return fmt.Errorf("error deleting department: %w", err)
	}

	return nil
}

// GetAllDepartments gets all departments
func (s *departmentService) GetAllDepartments(ctx context.Context, limit, offset int) ([]*dto.DepartmentResponse, error) {
	departments, err := s.departmentRepo.List(ctx, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("error listing departments: %w", err)
	}

	// Convert to response DTOs
	response := make([]*dto.DepartmentResponse, 0, len(departments))
	for _, department := range departments {
		// Get user count
		userCount, err := s.departmentRepo.GetUserCount(ctx, department.ID)
		if err != nil {
			// Log the error but continue
			fmt.Printf("Error getting user count: %v\n", err)
			userCount = 0
		}

		response = append(response, &dto.DepartmentResponse{
			ID:          department.ID,
			Name:        department.Name,
			Code:        department.Code,
			Description: department.Description,
			IsActive:    department.IsActive,
			UserCount:   userCount,
		})
	}

	return response, nil
}

// CountDepartments gets the total number of departments
func (s *departmentService) CountDepartments(ctx context.Context) (int, error) {
	return s.departmentRepo.Count(ctx)
}

================
File: internal/service/operation_service.go
================
package service

import (
	"context"
	"encoding/json"
	"erp-excel/internal/dto"
	"erp-excel/internal/models"
	"erp-excel/internal/repository"
	"fmt"
	"time"
)

// OperationService interface
type OperationService interface {
	GetAllOperations(ctx context.Context) ([]*dto.OperationResponse, error)
	CheckUserAccess(ctx context.Context, userID int, operationCode string) (bool, error)
	LogAccess(ctx context.Context, userID int, operationCode string, params interface{}, ipAddress string) (int, error)
	UpdateLogStatus(ctx context.Context, logID int, status string) (bool, error)
	GetRecentLogs(ctx context.Context, limit int) ([]*models.AccessLog, error)
}

type operationService struct {
	operationRepo repository.OperationRepository
	userRepo      repository.UserRepository
	roleRepo      repository.RoleRepository
}

// NewOperationService creates a new operation service
func NewOperationService(
	operationRepo repository.OperationRepository,
	userRepo repository.UserRepository,
	roleRepo repository.RoleRepository,
) OperationService {
	return &operationService{
		operationRepo: operationRepo,
		userRepo:      userRepo,
		roleRepo:      roleRepo,
	}
}

// GetAllOperations gets all operations
func (s *operationService) GetAllOperations(ctx context.Context) ([]*dto.OperationResponse, error) {
	return s.operationRepo.GetAll(ctx)
}

// CheckUserAccess checks if a user has access to an operation
func (s *operationService) CheckUserAccess(ctx context.Context, userID int, operationCode string) (bool, error) {
	// Find operation by code
	operation, err := s.operationRepo.FindByCode(ctx, operationCode)
	if err != nil {
		return false, fmt.Errorf("error finding operation: %w", err)
	}

	// Check if user has access
	return s.roleRepo.CheckUserOperationAccess(ctx, userID, operation.ID)
}

// LogAccess logs access to an operation
func (s *operationService) LogAccess(
	ctx context.Context,
	userID int,
	operationCode string,
	params interface{},
	ipAddress string,
) (int, error) {
	// Find operation by code
	operation, err := s.operationRepo.FindByCode(ctx, operationCode)
	if err != nil {
		return 0, fmt.Errorf("error finding operation: %w", err)
	}

	// Create access log
	log := &models.AccessLog{
		UserID:      userID,
		OperationID: operation.ID,
		AccessTime:  time.Now(),
		IPAddress:   ipAddress,
		Status:      "pending",
	}

	// Convert params to JSON string if provided
	if params != nil {
		jsonStr, err := json.Marshal(params)
		if err != nil {
			return 0, fmt.Errorf("error marshalling params: %w", err)
		}
		log.SearchParams = string(jsonStr)
	}

	// Save to database
	return s.operationRepo.LogAccess(ctx, log)
}

// UpdateLogStatus updates the status of an access log
func (s *operationService) UpdateLogStatus(ctx context.Context, logID int, status string) (bool, error) {
	if logID <= 0 {
		return false, fmt.Errorf("invalid log ID: %d", logID)
	}

	return s.operationRepo.UpdateLogStatus(ctx, logID, status)
}

// GetRecentLogs gets recent access logs
func (s *operationService) GetRecentLogs(ctx context.Context, limit int) ([]*models.AccessLog, error) {
	if limit <= 0 {
		limit = 10
	} else if limit > 100 {
		limit = 100
	}

	return s.operationRepo.GetRecentLogs(ctx, limit)
}

================
File: internal/service/report_service.go
================
package service

import (
	"context"
	"database/sql"
	"encoding/json"
	"erp-excel/config"
	"erp-excel/internal/dto"
	"erp-excel/internal/models"
	"erp-excel/internal/repository"
	"erp-excel/internal/utils"
	"errors"
	"fmt"
	"log"
	"path/filepath"
	"strings"
	"time"
)

// ReportService interface defines methods for report generation.
type ReportService interface {
	GetInventoryReportData(ctx context.Context, userID int, departmentID int, request *dto.DateRangeRequest) ([]dto.InventoryReportItem, error)
	ExportInventoryReport(ctx context.Context, userID int, departmentID int, request *dto.DateRangeRequest) (*dto.ReportFileResponse, error)
}

type reportService struct {
	erpDB         *sql.DB
	config        *config.Config
	userRepo      repository.UserRepository
	operationRepo repository.OperationRepository
	inventoryRepo repository.InventoryRepository
}

// NewReportService creates a new report service.
func NewReportService(
	erpDB *sql.DB,
	config *config.Config,
	userRepo repository.UserRepository,
	operationRepo repository.OperationRepository,
	inventoryRepo repository.InventoryRepository,
) ReportService {
	return &reportService{
		erpDB:         erpDB,
		config:        config,
		userRepo:      userRepo,
		operationRepo: operationRepo,
		inventoryRepo: inventoryRepo,
	}
}

// resolveDateRange calculates actual fromDate and toDate based on Period or uses provided dates.
func (s *reportService) resolveDateRange(request *dto.DateRangeRequest) (time.Time, time.Time, error) {
	now := time.Now()
	// toDate is always end of today for "X days/months latest" or the provided ToDate
	// Truncate to the beginning of the day, then add 23h 59m 59s 999ms 999us 999ns to get to end of day.
	// This ensures consistency when dealing with date ranges.
	currentEndOfDay := now.Truncate(24 * time.Hour).Add(24*time.Hour - time.Nanosecond)
	fromDate := time.Time{}
	toDate := time.Time{}

	if request.Period != "" {
		switch request.Period {
		case "7days":
			// 7 days includes today: today and the past 6 days.
			fromDate = currentEndOfDay.AddDate(0, 0, -6).Truncate(24 * time.Hour)
			toDate = currentEndOfDay
		case "30days":
			// 30 days includes today: today and the past 29 days.
			fromDate = currentEndOfDay.AddDate(0, 0, -29).Truncate(24 * time.Hour)
			toDate = currentEndOfDay
		case "3months":
			// 3 months includes today: starting from the first day of the month 3 months ago until today.
			// Example: if today is 2023-11-20, 3 months ago is 2023-08-20. We want from 2023-08-01.
			// AddDate(0, -3, 1) goes back 3 months and then adds 1 day to ensure it lands on the first day of that month.
			fromDate = time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location()).AddDate(0, -2, 0).Truncate(24 * time.Hour) // First day of 3 months ago
			toDate = currentEndOfDay
		case "currentmonth":
			fromDate = time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location())
			toDate = currentEndOfDay // End of current day, could also be end of current month if desired
		case "lastmonth":
			firstOfThisMonth := time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location())
			toDate = firstOfThisMonth.Add(-time.Nanosecond)                                    // End of last month
			fromDate = time.Date(toDate.Year(), toDate.Month(), 1, 0, 0, 0, 0, now.Location()) // First day of last month
		default:
			return time.Time{}, time.Time{}, fmt.Errorf("invalid period specified: %s", request.Period)
		}
	} else {
		// If Period is not specified, use FromDate and ToDate from request
		if request.FromDate.IsZero() || request.ToDate.IsZero() {
			return time.Time{}, time.Time{}, errors.New("fromDate and toDate are required if period is not specified")
		}
		fromDate = request.FromDate.Truncate(24 * time.Hour)
		toDate = request.ToDate.Truncate(24 * time.Hour).Add(24*time.Hour - time.Nanosecond) // Ensure toDate is end of day
	}

	return fromDate, toDate, nil
}

// GetInventoryReportData retrieves inventory report data without generating a file.
func (s *reportService) GetInventoryReportData(
	ctx context.Context,
	userID int,
	departmentID int,
	request *dto.DateRangeRequest,
) ([]dto.InventoryReportItem, error) {
	// Resolve actual fromDate and toDate based on request (period or explicit dates)
	resolvedFromDate, resolvedToDate, err := s.resolveDateRange(request)
	if err != nil {
		return nil, err
	}

	// Validate the resolved date range (e.g., within maxMonths allowed)
	if err := s.validateDateRange(resolvedFromDate, resolvedToDate); err != nil {
		return nil, err
	}

	// Log access attempt with resolved dates for clarity in logs
	logRequest := *request // Create a copy of the original request
	logRequest.FromDate = resolvedFromDate
	logRequest.ToDate = resolvedToDate
	searchParams, _ := json.Marshal(logRequest)

	accessLog := &models.AccessLog{
		UserID:       userID,
		OperationID:  1, // Assuming operation ID 1 is for inventory report data view
		AccessTime:   time.Now(),
		SearchParams: string(searchParams),
		Status:       "pending",
	}

	logID, err := s.operationRepo.LogAccess(ctx, accessLog)
	if err != nil {
		log.Printf("Error logging access: %v", err)
	}

	// Execute query using the repository with resolved dates
	items, err := s.inventoryRepo.GetInventoryReport(ctx, resolvedFromDate, resolvedToDate, departmentID)
	if err != nil {
		s.updateLogStatus(ctx, logID, "error")
		return nil, fmt.Errorf("error querying inventory data: %w", err)
	}

	// If no items found, return an empty slice to avoid nil pointer issues
	if len(items) == 0 {
		log.Printf("No data found for date range from %s to %s",
			resolvedFromDate.Format("2006-01-02"),
			resolvedToDate.Format("2006-01-02"))
		s.updateLogStatus(ctx, logID, "success") // Still a success even if no data
		return []dto.InventoryReportItem{}, nil
	}

	// Update log status to success
	s.updateLogStatus(ctx, logID, "success")

	return items, nil
}

// ExportInventoryReport generates and exports the inventory report to an Excel file.
func (s *reportService) ExportInventoryReport(
	ctx context.Context,
	userID int,
	departmentID int,
	request *dto.DateRangeRequest,
) (*dto.ReportFileResponse, error) {
	// Resolve actual fromDate and toDate
	resolvedFromDate, resolvedToDate, err := s.resolveDateRange(request)
	if err != nil {
		return nil, err
	}

	// Validate the resolved date range
	if err := s.validateDateRange(resolvedFromDate, resolvedToDate); err != nil {
		return nil, err
	}

	// Log access attempt for export
	logRequest := *request // Create a copy
	logRequest.FromDate = resolvedFromDate
	logRequest.ToDate = resolvedToDate
	searchParams, _ := json.Marshal(logRequest)

	accessLog := &models.AccessLog{
		UserID:       userID,
		OperationID:  2, // Assuming operation ID 2 is for inventory report export
		AccessTime:   time.Now(),
		SearchParams: string(searchParams),
		Status:       "pending",
	}

	logID, err := s.operationRepo.LogAccess(ctx, accessLog)
	if err != nil {
		log.Printf("Error logging access for export: %v", err)
	}

	// Get data using the repository
	items, err := s.inventoryRepo.GetInventoryReport(ctx, resolvedFromDate, resolvedToDate, departmentID)
	if err != nil {
		s.updateLogStatus(ctx, logID, "error")
		return nil, fmt.Errorf("error getting inventory data for export: %w", err)
	}

	if len(items) == 0 {
		s.updateLogStatus(ctx, logID, "success") // Exporting no data is also a success
		return nil, errors.New("no data found to export for the specified date range")
	}

	// Prepare title for the Excel file
	title := fmt.Sprintf("Báo cáo tồn kho từ %s đến %s",
		resolvedFromDate.Format("02/01/2006"),
		resolvedToDate.Format("02/01/2006"),
	)

	headers := []string{
		"Ngày CT",
		"Mã Đơn Bán Hàng",
		"Khách Hàng",
		"Mã Phiếu Kết Số",
		"Nguyên Tệ",
		"Nội Tệ",
		"Mã Đơn Hàng Chi Tiết",
		"Hóa Đơn",
		"Ghi Chú",
	}

	// Prepare data for Excel export
	data := make([]map[string]interface{}, len(items))
	for i, item := range items {
		data[i] = map[string]interface{}{
			"Ngày CT":              item.NgayCT,
			"Mã Đơn Bán Hàng":      item.MaDonBanHang,
			"Khách Hàng":           item.KhachHang,
			"Mã Phiếu Kết Số":      item.MaPhieuKetSo,
			"Nguyên Tệ":            item.NguyenTe,
			"Nội Tệ":               item.NoiTe,
			"Mã Đơn Hàng Chi Tiết": item.MaDonHangChiTiet,
			"Hóa Đơn":              item.HoaDon,
			"Ghi Chú":              item.GhiChu,
		}
	}

	// Generate Excel file using utils
	filePath, err := utils.ExportToExcel(data, headers, title)
	if err != nil {
		s.updateLogStatus(ctx, logID, "error")
		return nil, fmt.Errorf("error exporting to Excel: %w", err)
	}

	// Update log status to success
	s.updateLogStatus(ctx, logID, "success")

	// Prepare response for frontend
	fileName := filepath.Base(filePath)
	urlPath := strings.TrimPrefix(filePath, "public") // Adjust if your public path is different

	return &dto.ReportFileResponse{
		ReportName:  title,
		FilePath:    filePath,
		FileName:    fileName,
		URL:         urlPath,
		GeneratedAt: time.Now(),
	}, nil
}

// validateDateRange validates date range for reports.
// This is an internal helper, not exposed via interface.
func (s *reportService) validateDateRange(fromDate, toDate time.Time) error {
	// Check that fromDate is before or equal to toDate
	if fromDate.After(toDate) {
		return errors.New("from date must be before or equal to to date")
	}

	// Check that toDate is not in the future (compared to current end of day)
	nowEndOfDay := time.Now().Truncate(24 * time.Hour).Add(24*time.Hour - time.Nanosecond)
	if toDate.After(nowEndOfDay) {
		return errors.New("to date cannot be in the future")
	}

	// Check that date range is within allowed months
	maxMonths := s.config.Excel.MaxSearchMonths
	// Calculate the earliest allowed date from the perspective of the *resolved toDate*.
	// This makes the "maxMonths" constraint relative to the end of the selected period,
	// which is often more intuitive for users (e.g., "3 months from the end of the report").
	// Or, if it should always be relative to *today*, use `time.Now()` instead of `toDate`.
	// I'll keep it relative to today for consistency with common business rules for reports.
	oldestAllowed := time.Now().Truncate(24*time.Hour).AddDate(0, -maxMonths, 0)

	if fromDate.Truncate(24 * time.Hour).Before(oldestAllowed) {
		return fmt.Errorf("date range cannot exceed %d months from current date", maxMonths)
	}

	return nil
}

// updateLogStatus updates the status of an access log.
func (s *reportService) updateLogStatus(ctx context.Context, logID int, status string) {
	if logID <= 0 {
		return // Do not attempt to update if logID is invalid
	}

	if _, err := s.operationRepo.UpdateLogStatus(ctx, logID, status); err != nil {
		log.Printf("Error updating log status for logID %d: %v", logID, err)
	}
}

================
File: internal/service/role_service.go
================
package service

import (
	"context"
	"erp-excel/internal/dto"
	"erp-excel/internal/models"
	"erp-excel/internal/repository"
	"fmt"
)

// RoleService interface
type RoleService interface {
	CreateRole(ctx context.Context, request dto.CreateRoleRequest) (*dto.RoleResponse, error)
	GetRoleByID(ctx context.Context, id int) (*dto.RoleResponse, error)
	UpdateRole(ctx context.Context, id int, request dto.UpdateRoleRequest) (*dto.RoleResponse, error)
	DeleteRole(ctx context.Context, id int) error
	GetAllRoles(ctx context.Context, limit, offset int) ([]*dto.RoleResponse, error)
	CountRoles(ctx context.Context) (int, error)
	AssignOperations(ctx context.Context, roleID int, operationIDs []int) error
}

type roleService struct {
	roleRepo repository.RoleRepository
}

// NewRoleService creates a new role service
func NewRoleService(roleRepo repository.RoleRepository) RoleService {
	return &roleService{
		roleRepo: roleRepo,
	}
}

// CreateRole creates a new role
func (s *roleService) CreateRole(ctx context.Context, request dto.CreateRoleRequest) (*dto.RoleResponse, error) {
	// Create role model
	role := &models.Role{
		Name:        request.Name,
		Description: request.Description,
	}

	// Save to database
	createdRole, err := s.roleRepo.Create(ctx, role)
	if err != nil {
		return nil, fmt.Errorf("error creating role: %w", err)
	}

	// Assign operations if provided
	if len(request.OperationIDs) > 0 {
		if err := s.roleRepo.AssignOperations(ctx, createdRole.ID, request.OperationIDs); err != nil {
			return nil, fmt.Errorf("error assigning operations: %w", err)
		}
	}

	// Return response
	return &dto.RoleResponse{
		ID:           createdRole.ID,
		Name:         createdRole.Name,
		Description:  createdRole.Description,
		CreatedAt:    createdRole.CreatedAt,
		UpdatedAt:    createdRole.UpdatedAt,
		OperationIDs: request.OperationIDs,
	}, nil
}

// GetRoleByID gets a role by ID
func (s *roleService) GetRoleByID(ctx context.Context, id int) (*dto.RoleResponse, error) {
	role, err := s.roleRepo.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("error getting role: %w", err)
	}

	// Extract operation IDs
	operationIDs := make([]int, 0, len(role.Operations))
	for _, operation := range role.Operations {
		operationIDs = append(operationIDs, operation.ID)
	}

	return &dto.RoleResponse{
		ID:           role.ID,
		Name:         role.Name,
		Description:  role.Description,
		CreatedAt:    role.CreatedAt,
		UpdatedAt:    role.UpdatedAt,
		OperationIDs: operationIDs,
	}, nil
}

// UpdateRole updates a role
func (s *roleService) UpdateRole(ctx context.Context, id int, request dto.UpdateRoleRequest) (*dto.RoleResponse, error) {
	// Get existing role
	role, err := s.roleRepo.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("error getting role: %w", err)
	}

	// Update fields if provided
	if request.Name != "" {
		role.Name = request.Name
	}

	if request.Description != "" {
		role.Description = request.Description
	}

	// Save to database
	if err := s.roleRepo.Update(ctx, role); err != nil {
		return nil, fmt.Errorf("error updating role: %w", err)
	}

	// Update operations if provided
	if len(request.OperationIDs) > 0 {
		if err := s.roleRepo.AssignOperations(ctx, role.ID, request.OperationIDs); err != nil {
			return nil, fmt.Errorf("error assigning operations: %w", err)
		}

		// Reload operations
		role, err = s.roleRepo.GetByID(ctx, id)
		if err != nil {
			return nil, fmt.Errorf("error reloading role: %w", err)
		}
	}

	// Extract operation IDs
	operationIDs := make([]int, 0, len(role.Operations))
	for _, operation := range role.Operations {
		operationIDs = append(operationIDs, operation.ID)
	}

	// Return response
	return &dto.RoleResponse{
		ID:           role.ID,
		Name:         role.Name,
		Description:  role.Description,
		CreatedAt:    role.CreatedAt,
		UpdatedAt:    role.UpdatedAt,
		OperationIDs: operationIDs,
	}, nil
}

// DeleteRole deletes a role
func (s *roleService) DeleteRole(ctx context.Context, id int) error {
	return s.roleRepo.Delete(ctx, id)
}

// GetAllRoles gets all roles
func (s *roleService) GetAllRoles(ctx context.Context, limit, offset int) ([]*dto.RoleResponse, error) {
	roles, err := s.roleRepo.List(ctx, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("error listing roles: %w", err)
	}

	// Convert to response DTOs
	response := make([]*dto.RoleResponse, 0, len(roles))
	for _, role := range roles {
		// Get operations for this role
		operations, err := s.roleRepo.GetOperations(ctx, role.ID)
		if err != nil {
			return nil, fmt.Errorf("error getting operations for role: %w", err)
		}

		// Extract operation IDs
		operationIDs := make([]int, 0, len(operations))
		for _, operation := range operations {
			operationIDs = append(operationIDs, operation.ID)
		}

		response = append(response, &dto.RoleResponse{
			ID:           role.ID,
			Name:         role.Name,
			Description:  role.Description,
			CreatedAt:    role.CreatedAt,
			UpdatedAt:    role.UpdatedAt,
			OperationIDs: operationIDs,
		})
	}

	return response, nil
}

// CountRoles gets the total number of roles
func (s *roleService) CountRoles(ctx context.Context) (int, error) {
	return s.roleRepo.Count(ctx)
}

// AssignOperations assigns operations to a role
func (s *roleService) AssignOperations(ctx context.Context, roleID int, operationIDs []int) error {
	return s.roleRepo.AssignOperations(ctx, roleID, operationIDs)
}

================
File: internal/service/user_service.go
================
package service

import (
	"context"
	"erp-excel/internal/dto"
	"erp-excel/internal/models"
	"erp-excel/internal/repository"
	"erp-excel/internal/utils"
	"errors"
	"fmt"
)

// UserService interface
type UserService interface {
	CreateUser(ctx context.Context, request dto.CreateUserRequest) (*dto.UserResponse, error)
	GetUserByID(ctx context.Context, id int) (*dto.UserResponse, error)
	UpdateUser(ctx context.Context, id int, request dto.UpdateUserRequest) (*dto.UserResponse, error)
	UpdateUserPassword(ctx context.Context, id int, request dto.UpdatePasswordRequest) error
	DeleteUser(ctx context.Context, id int) error
	GetAllUsers(ctx context.Context, limit, offset int) ([]*dto.UserResponse, error)
	CountUsers(ctx context.Context) (int, error)
	AssignRolesToUser(ctx context.Context, userID int, roleIDs []int) error
}

type userService struct {
	userRepo       repository.UserRepository
	departmentRepo repository.DepartmentRepository
	roleRepo       repository.RoleRepository
	authService    AuthService
}

// NewUserService creates a new user service
func NewUserService(
	userRepo repository.UserRepository,
	departmentRepo repository.DepartmentRepository,
	roleRepo repository.RoleRepository,
	authService AuthService,
) UserService {
	return &userService{
		userRepo:       userRepo,
		departmentRepo: departmentRepo,
		roleRepo:       roleRepo,
		authService:    authService,
	}
}

// CreateUser creates a new user
func (s *userService) CreateUser(ctx context.Context, request dto.CreateUserRequest) (*dto.UserResponse, error) {
	// Validate department exists
	department, err := s.departmentRepo.GetByID(ctx, request.DepartmentID)
	if err != nil {
		return nil, fmt.Errorf("invalid department: %w", err)
	}

	// Hash password
	hashedPassword, err := utils.HashPassword(request.Password)
	if err != nil {
		return nil, fmt.Errorf("error hashing password: %w", err)
	}

	// Create user model
	user := &models.User{
		Username:     request.Username,
		Password:     hashedPassword,
		FullName:     request.FullName,
		Email:        request.Email,
		Phone:        request.Phone,
		DepartmentID: request.DepartmentID,
		IsActive:     true,
	}

	// Save to database
	createdUser, err := s.userRepo.Create(ctx, user)
	if err != nil {
		return nil, fmt.Errorf("error creating user: %w", err)
	}

	// Assign roles
	if err := s.userRepo.AssignRoles(ctx, createdUser.ID, request.RoleIDs); err != nil {
		return nil, fmt.Errorf("error assigning roles: %w", err)
	}

	// Get roles for response
	roles, err := s.userRepo.GetUserRoles(ctx, createdUser.ID)
	if err != nil {
		return nil, fmt.Errorf("error getting user roles: %w", err)
	}

	// Extract role names
	roleNames := make([]string, 0, len(roles))
	for _, role := range roles {
		roleNames = append(roleNames, role.Name)
	}

	// Return response
	return &dto.UserResponse{
		ID:           createdUser.ID,
		Username:     createdUser.Username,
		FullName:     createdUser.FullName,
		Email:        createdUser.Email,
		Phone:        createdUser.Phone,
		DepartmentID: createdUser.DepartmentID,
		Department:   department.Name,
		IsActive:     createdUser.IsActive,
		CreatedAt:    createdUser.CreatedAt,
		Roles:        roleNames,
	}, nil
}

// GetUserByID gets a user by ID
func (s *userService) GetUserByID(ctx context.Context, id int) (*dto.UserResponse, error) {
	user, err := s.userRepo.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("error getting user: %w", err)
	}

	// Extract role names
	roleNames := make([]string, 0, len(user.Roles))
	for _, role := range user.Roles {
		roleNames = append(roleNames, role.Name)
	}

	// Create response
	return &dto.UserResponse{
		ID:           user.ID,
		Username:     user.Username,
		FullName:     user.FullName,
		Email:        user.Email,
		Phone:        user.Phone,
		DepartmentID: user.DepartmentID,
		Department:   user.Department.Name,
		IsActive:     user.IsActive,
		CreatedAt:    user.CreatedAt,
		Roles:        roleNames,
	}, nil
}

// UpdateUser updates a user
func (s *userService) UpdateUser(ctx context.Context, id int, request dto.UpdateUserRequest) (*dto.UserResponse, error) {
	// Get existing user
	user, err := s.userRepo.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("error getting user: %w", err)
	}

	// Update fields if provided
	if request.FullName != "" {
		user.FullName = request.FullName
	}

	if request.Email != "" {
		user.Email = request.Email
	}

	if request.Phone != "" {
		user.Phone = request.Phone
	}

	if request.DepartmentID != 0 {
		// Validate department exists
		if _, err := s.departmentRepo.GetByID(ctx, request.DepartmentID); err != nil {
			return nil, fmt.Errorf("invalid department: %w", err)
		}
		user.DepartmentID = request.DepartmentID
	}

	if request.IsActive != nil {
		user.IsActive = *request.IsActive
	}

	// Save to database
	if err := s.userRepo.Update(ctx, user); err != nil {
		return nil, fmt.Errorf("error updating user: %w", err)
	}

	// Get department name
	department, err := s.departmentRepo.GetByID(ctx, user.DepartmentID)
	if err != nil {
		// Log error but don't fail the operation
		fmt.Printf("Error getting department: %v\n", err)
	}

	// Get roles for response
	roles, err := s.userRepo.GetUserRoles(ctx, user.ID)
	if err != nil {
		return nil, fmt.Errorf("error getting user roles: %w", err)
	}

	// Extract role names
	roleNames := make([]string, 0, len(roles))
	for _, role := range roles {
		roleNames = append(roleNames, role.Name)
	}

	// Return response
	departmentName := ""
	if department != nil {
		departmentName = department.Name
	}

	return &dto.UserResponse{
		ID:           user.ID,
		Username:     user.Username,
		FullName:     user.FullName,
		Email:        user.Email,
		Phone:        user.Phone,
		DepartmentID: user.DepartmentID,
		Department:   departmentName,
		IsActive:     user.IsActive,
		CreatedAt:    user.CreatedAt,
		Roles:        roleNames,
	}, nil
}

// UpdateUserPassword updates a user's password
func (s *userService) UpdateUserPassword(ctx context.Context, id int, request dto.UpdatePasswordRequest) error {
	// Get existing user
	user, err := s.userRepo.GetByID(ctx, id)
	if err != nil {
		return fmt.Errorf("error getting user: %w", err)
	}

	// Verify current password
	if !utils.CheckPasswordHash(request.CurrentPassword, user.Password) {
		return errors.New("current password is incorrect")
	}

	// Check that new password and confirmation match
	if request.NewPassword != request.ConfirmPassword {
		return errors.New("new password and confirmation do not match")
	}

	// Hash new password
	hashedPassword, err := utils.HashPassword(request.NewPassword)
	if err != nil {
		return fmt.Errorf("error hashing password: %w", err)
	}

	// Update password
	if err := s.userRepo.UpdatePassword(ctx, id, hashedPassword); err != nil {
		return fmt.Errorf("error updating password: %w", err)
	}

	return nil
}

// DeleteUser deletes (deactivates) a user
func (s *userService) DeleteUser(ctx context.Context, id int) error {
	return s.userRepo.Delete(ctx, id)
}

// GetAllUsers gets all users with pagination
func (s *userService) GetAllUsers(ctx context.Context, limit, offset int) ([]*dto.UserResponse, error) {
	users, err := s.userRepo.List(ctx, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("error listing users: %w", err)
	}

	// Convert to response DTOs
	response := make([]*dto.UserResponse, 0, len(users))
	for _, user := range users {
		// Get roles for this user
		roles, err := s.userRepo.GetUserRoles(ctx, user.ID)
		if err != nil {
			return nil, fmt.Errorf("error getting roles for user: %w", err)
		}

		// Extract role names
		roleNames := make([]string, 0, len(roles))
		for _, role := range roles {
			roleNames = append(roleNames, role.Name)
		}

		departmentName := ""
		if user.Department != nil {
			departmentName = user.Department.Name
		}

		response = append(response, &dto.UserResponse{
			ID:           user.ID,
			Username:     user.Username,
			FullName:     user.FullName,
			Email:        user.Email,
			Phone:        user.Phone,
			DepartmentID: user.DepartmentID,
			Department:   departmentName,
			IsActive:     user.IsActive,
			CreatedAt:    user.CreatedAt,
			Roles:        roleNames,
		})
	}

	return response, nil
}

// CountUsers gets the total number of users
func (s *userService) CountUsers(ctx context.Context) (int, error) {
	return s.userRepo.Count(ctx)
}

// AssignRolesToUser assigns roles to a user
func (s *userService) AssignRolesToUser(ctx context.Context, userID int, roleIDs []int) error {
	return s.userRepo.AssignRoles(ctx, userID, roleIDs)
}

================
File: internal/utils/excel_exporter.go
================
package utils

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/xuri/excelize/v2"
)

// ExportToExcel exports data to Excel file
func ExportToExcel(data []map[string]interface{}, headers []string, title string) (string, error) {
	// Create a new Excel file
	f := excelize.NewFile()
	defer f.Close()

	// Get the default sheet
	sheetName := "Sheet1"

	// Set title
	f.SetCellValue(sheetName, "A1", title)

	// Set title style
	titleStyle, err := f.NewStyle(&excelize.Style{
		Font: &excelize.Font{
			Size:  16,
			Bold:  true,
			Color: "1F497D",
		},
		Alignment: &excelize.Alignment{
			Horizontal: "center",
			Vertical:   "center",
		},
	})
	if err != nil {
		return "", fmt.Errorf("error creating title style: %w", err)
	}

	// Apply title style and merge cells for title
	f.SetCellStyle(sheetName, "A1", fmt.Sprintf("%c1", rune('A'+len(headers)-1)), titleStyle)
	f.MergeCell(sheetName, "A1", fmt.Sprintf("%c1", rune('A'+len(headers)-1)))

	// Set headers
	headerStyle, err := f.NewStyle(&excelize.Style{
		Font: &excelize.Font{
			Bold:  true,
			Color: "FFFFFF",
		},
		Fill: excelize.Fill{
			Type:    "pattern",
			Color:   []string{"4472C4"},
			Pattern: 1,
		},
		Border: []excelize.Border{
			{Type: "left", Color: "000000", Style: 1},
			{Type: "top", Color: "000000", Style: 1},
			{Type: "bottom", Color: "000000", Style: 1},
			{Type: "right", Color: "000000", Style: 1},
		},
		Alignment: &excelize.Alignment{
			Horizontal: "center",
			Vertical:   "center",
		},
	})
	if err != nil {
		return "", fmt.Errorf("error creating header style: %w", err)
	}

	// Write headers
	for i, header := range headers {
		cellPos := fmt.Sprintf("%c3", rune('A'+i))
		f.SetCellValue(sheetName, cellPos, header)
	}

	// Apply header style
	headerRange := fmt.Sprintf("A3:%c3", rune('A'+len(headers)-1))
	f.SetCellStyle(sheetName, headerRange, headerRange, headerStyle)

	// Data cell styles
	dataStyle, err := f.NewStyle(&excelize.Style{
		Border: []excelize.Border{
			{Type: "left", Color: "000000", Style: 1},
			{Type: "top", Color: "000000", Style: 1},
			{Type: "bottom", Color: "000000", Style: 1},
			{Type: "right", Color: "000000", Style: 1},
		},
		Alignment: &excelize.Alignment{
			Vertical: "center",
		},
	})
	if err != nil {
		return "", fmt.Errorf("error creating data style: %w", err)
	}

	// Number format style
	numberStyle, err := f.NewStyle(&excelize.Style{
		Border: []excelize.Border{
			{Type: "left", Color: "000000", Style: 1},
			{Type: "top", Color: "000000", Style: 1},
			{Type: "bottom", Color: "000000", Style: 1},
			{Type: "right", Color: "000000", Style: 1},
		},
		Alignment: &excelize.Alignment{
			Horizontal: "right",
			Vertical:   "center",
		},
		NumFmt: 3, // #,##0 format
	})
	if err != nil {
		return "", fmt.Errorf("error creating number style: %w", err)
	}

	// Write data
	for i, item := range data {
		row := i + 4 // Data starts from row 4

		for j, header := range headers {
			cellPos := fmt.Sprintf("%c%d", rune('A'+j), row)
			f.SetCellValue(sheetName, cellPos, item[header])

			// Apply style based on data type
			switch header {
			case "Mã sản phẩm", "Tên sản phẩm", "Đơn vị":
				f.SetCellStyle(sheetName, cellPos, cellPos, dataStyle)
			default:
				f.SetCellStyle(sheetName, cellPos, cellPos, numberStyle)
			}
		}
	}

	// Set column width
	for i := range headers {
		colName := string(rune('A' + i))
		f.SetColWidth(sheetName, colName, colName, 15)
	}

	// Set row height
	f.SetRowHeight(sheetName, 1, 30)
	f.SetRowHeight(sheetName, 3, 25)

	// Generate timestamp for filename
	timestamp := time.Now().Format("20060102_150405")

	// Create downloads directory if it doesn't exist
	downloadPath := "public/downloads"
	if err := os.MkdirAll(downloadPath, 0755); err != nil {
		return "", fmt.Errorf("error creating downloads directory: %w", err)
	}

	// Create sanitized filename
	safeTitlePart := sanitizeFilename(title)
	if len(safeTitlePart) > 30 {
		safeTitlePart = safeTitlePart[:30]
	}

	// Complete filename
	filename := fmt.Sprintf("%s_%s.xlsx", safeTitlePart, timestamp)
	filePath := filepath.Join(downloadPath, filename)

	// Save the file
	if err := f.SaveAs(filePath); err != nil {
		return "", fmt.Errorf("error saving Excel file: %w", err)
	}

	return filePath, nil
}

// sanitizeFilename removes invalid characters from filename
func sanitizeFilename(name string) string {
	name = filepath.Clean(name)
	invalidChars := []rune{'<', '>', ':', '"', '/', '\\', '|', '?', '*'}

	for _, char := range invalidChars {
		name = strings.ReplaceAll(name, string(char), "_")
	}

	return name
}

================
File: internal/utils/file.go
================
package utils

import "os"

// FileExists checks if a file exists and is not a directory
func FileExists(filename string) bool {
	info, err := os.Stat(filename)
	if os.IsNotExist(err) {
		return false
	}
	return !info.IsDir()
}

================
File: internal/utils/password.go
================
package utils

import "golang.org/x/crypto/bcrypt"

// HashPassword creates a bcrypt hash from a password
func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// CheckPasswordHash compares a password with a hash
func CheckPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

================
File: internal/utils/response.go
================
package utils

import "github.com/gofiber/fiber/v2"

// SuccessResponse returns a standardized success response
func SuccessResponse(data interface{}, message string) fiber.Map {
	return fiber.Map{
		"success": true,
		"message": message,
		"data":    data,
	}
}

// ErrorResponse returns a standardized error response
func ErrorResponse(message string, error string) fiber.Map {
	return fiber.Map{
		"success": false,
		"message": message,
		"error":   error,
	}
}

// PaginatedResponse returns a response with pagination metadata
func PaginatedResponse(data interface{}, page, limit, total int, message string) fiber.Map {
	totalPages := (total + limit - 1) / limit
	hasNext := page < totalPages
	hasPrev := page > 1

	return fiber.Map{
		"success": true,
		"message": message,
		"data":    data,
		"pagination": fiber.Map{
			"total":       total,
			"page":        page,
			"limit":       limit,
			"total_pages": totalPages,
			"has_next":    hasNext,
			"has_prev":    hasPrev,
		},
	}
}

================
File: internal/utils/validator.go
================
package utils

import (
	"fmt"
	"strings"

	"github.com/go-playground/validator/v10"
)

var validate = validator.New()

// ValidateStruct validates a struct against its validation tags
func ValidateStruct(s interface{}) error {
	if err := validate.Struct(s); err != nil {
		if validationErrors, ok := err.(validator.ValidationErrors); ok {
			errorMessages := make([]string, 0, len(validationErrors))
			for _, e := range validationErrors {
				errorMessages = append(errorMessages, formatValidationError(e))
			}
			return fmt.Errorf("validation failed: %s", strings.Join(errorMessages, "; "))
		}
		return err
	}
	return nil
}

// formatValidationError formats a validation error into a human-readable message
func formatValidationError(e validator.FieldError) string {
	field := e.Field()
	tag := e.Tag()

	switch tag {
	case "required":
		return fmt.Sprintf("%s is required", field)
	case "email":
		return fmt.Sprintf("%s must be a valid email address", field)
	case "min":
		return fmt.Sprintf("%s must be at least %s", field, e.Param())
	case "max":
		return fmt.Sprintf("%s must be at most %s", field, e.Param())
	case "len":
		return fmt.Sprintf("%s must be exactly %s characters long", field, e.Param())
	case "eqfield":
		return fmt.Sprintf("%s must be equal to %s", field, e.Param())
	default:
		return fmt.Sprintf("%s failed on the '%s' validation", field, tag)
	}
}

================
File: config.yaml
================
server:
  name: KanBan
  port: 8080
  env: development

database:
  host: 192.168.0.200
  port: 1433  
  user: sa
  password: dsc@123
  name: TEST_KANBAN
  timeout: 10

# Thêm cấu hình database ERP
erp_database:
  host: 192.168.0.200
  port: 1433
  user: sa
  password: dsc@123
  name: Leader
  timeout: 10

jwt:
  secret: your_jwt_secret_key
  expiry_hour: 24

excel:
  download_path: public/downloads
  max_search_months: 6

logger:
  level: info
  path: logs/app.log

================
File: go.mod
================
module erp-excel

go 1.24.5

require (
	github.com/denisenkom/go-mssqldb v0.12.3
	github.com/go-playground/validator/v10 v10.27.0
	github.com/gofiber/fiber/v2 v2.52.9
	github.com/golang-jwt/jwt/v4 v4.5.2
	github.com/spf13/viper v1.20.1
	github.com/xuri/excelize/v2 v2.9.1
	golang.org/x/crypto v0.38.0
)

require (
	github.com/andybalholm/brotli v1.1.0 // indirect
	github.com/fsnotify/fsnotify v1.8.0 // indirect
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-viper/mapstructure/v2 v2.2.1 // indirect
	github.com/golang-sql/civil v0.0.0-20190719163853-cb61b32ac6fe // indirect
	github.com/golang-sql/sqlexp v0.1.0 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/klauspost/compress v1.17.9 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/pelletier/go-toml/v2 v2.2.3 // indirect
	github.com/richardlehane/mscfb v1.0.4 // indirect
	github.com/richardlehane/msoleps v1.0.4 // indirect
	github.com/rivo/uniseg v0.2.0 // indirect
	github.com/sagikazarmark/locafero v0.7.0 // indirect
	github.com/sourcegraph/conc v0.3.0 // indirect
	github.com/spf13/afero v1.12.0 // indirect
	github.com/spf13/cast v1.7.1 // indirect
	github.com/spf13/pflag v1.0.6 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	github.com/tiendc/go-deepcopy v1.6.0 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasthttp v1.51.0 // indirect
	github.com/valyala/tcplisten v1.0.0 // indirect
	github.com/xuri/efp v0.0.1 // indirect
	github.com/xuri/nfp v0.0.1 // indirect
	go.uber.org/atomic v1.9.0 // indirect
	go.uber.org/multierr v1.9.0 // indirect
	golang.org/x/net v0.40.0 // indirect
	golang.org/x/sys v0.33.0 // indirect
	golang.org/x/text v0.25.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)





================================================================
End of Codebase
================================================================
